---

---

# 常用软件及开发工具使用说明

## 其他常用命令

- 命令行基础

  - pipe 前一个命令的输出 (Output) 做为后一个命令的输入 (Input)
    - 管道符
    - IO xxx.io Google I/O 大会
    - input output
    - pm2 | grep "to" | lolcat vertical bar
  - cd change directory
    - cd 相对路径（相对于当前工作目录）
      - ../ 表示当前文件夹的父文件夹 （中合路径中的上一个文件夹）anv/.. =0
      - ./ 表示当前文件夹，可忽略
    - cd 绝对路径，, 以 / 开头； （cd - 上一个文件夹）
    - 补充：
      - 路径
      - 相对路径 以 / 开头
      - 绝对路径 以 // 开头
  - sudo /super user do 超级管理员
  - touch a.txt 创建（空）文件
  - time command 计算某命令的运行时间
  - date 显示时间和日期
  - cal 显示日历
  - //scp
  - //ping ip 测试与目标 ip 的连通性 （ping baidu.com)
    - sudo mkdir dir
    - gitlab 删库事件

### vi 编辑器

- 基础使用
- 达到可以在 vps 上编辑文本文件即可
- esc 从编辑模式返回常规模式
- i 常规模式下进入编辑模式
- :wq 常规模式下输入
  补充知识

## 定位 position

- 粘性定位 sticky
  粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定值前为相对定位，之后为固定定位。在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下；当其包含块的文档区脱离视口时，它会被包含块带走。元素在常规流的位置保留
- 层叠覆盖关系
  - 定位流盖住常规流
  - 后出现的定位流元素盖住前面定位流元素。所有定位脱离常规流的元素都在一个层面，在同一个位置上，后出现的元素会盖住前面的元素，需要设置 z-index 改变叠层
  - z-index 必须配合定位使用
    - 调节层叠覆盖关系，常规流默认值为 0
    - z-index: 值； 值大的盖住值小的，可以有负值，都为整数。

## 行内布局

- 空格的大小和字体一致，字体为 0 时没有空格。

- 模型：
  行内框在一行以内水平排列，空间不够后就折行
  一行的所有行内框形成行框
  行内框可以通过 vertical-align 做垂直微调
- 一个行内元素跨行会生成多个盒子
- 匿名文本
  所在属块元素的 line-height 框
- display: inline
  行内框也是仅通过 line-height 框确定
  所有额外的 padding，border 不影响行内框的生成
  对 inline 元素设置宽高无效
  当 inline 元素无 padding 及 border 时，其底色区域的高度为当前字体 line-height 为 normal 时的计算值，与实际设置的 line-height 无关。
- display: inline-block/table
  inline-block 元素内部没有文字或者触发 BFC 时，行内框为 margin-box 的外边缘；
  inline-block 元素内部有文字时，通过文字来调整对齐；
  基线为最后一行文字的基线 / 无内容时以 margin-box 下边缘为准
  考虑其自身位置 / 摆放时，当成图片考虑
  考虑其内容的布局时，当成块 / 表
- 只要行框形成，就要考虑那一行有一个匿名文本
- 对于替换元素（图片）
  设置 display：inline 无效，会当成 inline-block；

- vertical-align ：指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。
  baseline（默认值）
  使元素的基线与父元素的基线对齐。HTML 规范没有详细说明部分可替换元素的基线，如`<textarea>` ，这意味着这些元素使用此值的表现因浏览器而异。
  - 当元素设置为 inline-block 时，并且其 overflow 的值不为 visible，此时 baseline 对准的是其 margin-box 边缘
    middle
    使元素的中部与父元素的基线加上父元素 x-height（译注：x 高度）的一半对齐。 \*而当字体大小为 0 时，基线的位置就等于中线的位置，设置垂直居中时可以用到
    top
    使元素行内框的顶端与行框的顶端对齐。
    bottom
    使元素行内框的底端与行框的底端对齐。
    text-top
    使元素的顶部与父元素的字体在 lineheight=normal 时的顶部对齐。
    text-bottom
    使元素的底部与父元素的字体在 lineheight=normal 时底部对齐。
    sub
    使元素的基线与父元素的下标基线对齐。
    super
    使元素的基线与父元素的上标基线对齐。
    percentage
    使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是 line-height 属性的百分比。可以是负数。
    <length>
    使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。

## 表格

- table = display:table
  tr = display:table-row
  thead = display:table-header-group
  tbody = display:table-row-group
  tfoot = display:table-footer-group
  col = display:table-column
  colgroup = display:table-column-group
  td,th = display:table-cell
  caption = display:table-caption
- col/colgroup 的可用样式只有 border,background,width,visibility

- 表层 table--colgroup--col--tbody--tr--td，由小到大
- border-collapse:collapse 边框合并，默认为 separate，不合并； 合并之前只有 table 和 td 可以设置边框，合并后 tr tbody col colgroup 都可以设置边框，但是在同一个位置的边框都会合并。
  合并规则：1 值为 hidden 优先级最高，值为 none 优先级最低。
  2 优先级顺序（宽度：谁宽谁优先， 样式：double--solid--dashed--dotted， 颜色来源：和表层一致， 位置：左上方大于右下）
- table-layout：fixed； 设置表格宽度需要这个属性 ,table 没有这个属性时其宽度可以被 td 撑开，设置 fixed 后宽高会固定
  表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。在当前列中，该单元格所在行之后的行并不会影响整个列宽，设置 fixed 后就可以了；任何一个包含溢出内容的单元格可以使用 overflow 属性控制是否允许内容溢出
- 为 td 设置 text-align 为 center,vertical-align: middle 可以水平垂直居中
  td 里面的内容默认是垂直居中的，可以省略 vertical-align: middle
- 单元格的宽高都会默认内部文本不会超出；例如为左右两个 cell 设置 width 分别为 1% 和 100%；，左边的 cell 会尽量小，右边 cell 尽量宽，但是会忽略其比例，因为要保证其内部文本不超出。 若左右两个 cell 设置 width 分别为 40% 和 60%，而且空间足够包裹文字，则两边 cell 的比例就为 4:6；
- empty-cells：设置空单元格是否隐藏
- caption-side:top/bottom 属性会将表格的标题<caption> 放到规定的位置

## 浮动

- 浮动元素的布局盒子也是 margin box，是在包含块中浮动；浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止
- 块级元素无法感知浮动元素，行内元素可以感知到并且避开布局盒子。处于半常规流，和 fixed 和 absolute 一起用时不生效，和 relative 一起用时先浮动再相对定位。
- 浮动元素下移之后就不会再上移了，可以左移或者右移，
- 触发 BFC 浮动元素不会超出其包含块。触发 BFC 的块元素周围有浮动元素时，为了避开浮动元素 BFC 元素会变窄
- 在常规流中，行内元素盖住浮动元素，浮动元素盖住块级元素

- 浮动元素规则

  - 浮动元素的左右外边界不能超出包含块的左右内边界，浮动元素不会超过容器的上 padding
  - 当浮动元素的 width>容器的 width 时，这会使得浮动元素超出容器的左右边界，但它会向下移动到保证超出的部分最小。
  - 同一个包含块内浮动元素之间不能互相重叠
  - 元素浮动后会生成块级框，即浮动元素没必要指定 display:block
  - 浮动是在离其最近的块级祖先包含块中浮动
  - 浮动元素尽可能往上浮动
  - 浮动元素不能比前一个块级元素或浮动元素高。
  - 浮动元素的下边界没有要求，因此当容器不足以容下浮动元素时，浮动元素会向下延伸。这时可以用到闭合浮动

- 清除浮动：clear 元素，用于块元素，使其下移到两边没有浮动元素。块元素的 border box 和浮动元素的 marginbox 紧挨着；
- 闭合浮动：某个块框通过增加自己的高度使其能够包含其浮动的后代元素（通过自己变大，使所有后代浮动元素被自己包起来）
  闭合浮动的方式
  - 触发 BFC：
    overflow: hidden/auto/scroll;
    display: inline-block/table-cell/table/flow-root;
    position: absolute/fixed;
    float: 除 none 以外的值；
  - 在末尾使用一个行内元素生成的行框将其撑高
    缺点：会生成一个行框，有一定的高度
    font size=0,line height=0
  - 在末尾使用一个 clear:both 的块元素将其撑高
    优化：用 after 伪元素
  - <br clear="both">

## CSS 补充知识

### 伪元素

- div::before（位于开始标签之后） div::after（位于结束标签之前）
  这两个伪元素都是 div 的子元素 ，且都为行内元素，直接在 CSS 中使用。
  ::selection {被鼠标选中的文字，只能设置前景色和背景色}
  ::target {选中 id 的值为地址栏中#后的内容的元素}

- 伪元素后面不能加伪类，只能加在其父元素后面
  div:hover::before 对
  div::before:hover 错

- 伪元素的属性
  - content 属性，必要属性，它的值是文字或者空值，多个值之间用空格分开 content："" "asf" attr（父元素的属性） '空格' ；
    attr（父元素的属性） = 父元素的该属性值
    content： "/A" 回车换行符 需配合 white-space：pre 使用才可以实现换行

### 回流与重绘

- 回流 reflow relayout
  页面样式的变化涉及到重新计算布局
  在可能的情况下不要触发回流或把回流控制在一定的范围内
  因为回流速度更慢
  - 重绘 repaint
    速度快
    页面样式的变化不涉及布局的计算，只变了颜色，背景，阴影等不影响布局样式

### 新元素和属性收集

- pointer-evens
  默认值为 auto，鼠标可以交互
  值为 none 时，鼠标在对象里面无法交互，但是会指向其后代
- user-select:none; 元素无法被选中，多用于防止小说文本被复制盗版
- visibility，支持动画
  默认值 visible，可见
  hidden 内容隐藏，位置还在，不可交互； display:none 无法支持动画，可选择 visibility 属性
  collapse 用于 <table> 行、列、列组和行组，隐藏表格的行或列，并且不占用任何空间（与将 display: none 用于表格的行 / 列上的效果相当）
  z-index: 也支持动画
- min-height/width max-height/width 设置元素宽高的最大最小数值 ，浏览器的窗口不是 html 元素，浏览器的窗口大小不能由这两个属性控制，有浏览器默认控制。
- clip-path CSS 属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。
  clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); 不规则图形，四个坐标对应 4 个点；
  - 列表图标
    list-style-image:url() 图片会原比例尺寸插入，无法调整大小和位置，几乎不用
    list-style-position:inside ：设置图标在 li`边框的内外部
    list-style-type:decimal：设置图标的样式，圆，方块，10 进制等
  - <link  media="print"> 设置代码在哪种设备中生效
  - 计数器 counter
    counter-increment: 计数器名（遇到该计数器开始计数） 数字（加几，默认 1）
    counter-reset：计数器名（遇到该计数器重置） 数字（重置为几，默认 0）
  - 打印断页
    page-break-before：avoid/always 该标签前面不断页 / 断页
    page-break-after :avoid/always 该标签后面不断页 / 断页
    page-break-inside : avoid 该标签永远在一个页面里面
  - all:initial 所有属性回到初始值，即浏览器默认值
  - 如何禁用 textarea 元素默认的可缩放行为？
    textarea {
    resize: none;
    }
  - 为所有元素设置 box-sizing 较好的方法
    html {
    box-sizing: border-box;
    }
    \*,::before,::after {
    box-sizing: inherit;
    }
  - background-clip :border-box/padding-box/content-box
    设置元素的背景（背景图片或颜色）是否延伸到边框下面。
    background-size：contain 缩放背景图片以完全装入背景区，可能背景区部分空白，保持图像的宽高比例（图像不会被压缩） /cover 缩放背景图片以完全装入背景区，保持图像的宽高比例，可能背景图片部分看不见
    background-color: 背景颜色
    background-image：背景图片
    background—repeat: 背景图片的重复与否
    backgrounf-origin: 定了指定背景图片 background-image 属性的原点位置的背景相对区域。
    background-position: 为每一个背景图片设置初始位置。 这个位置是相对于由 background-origin 定义的位置图层的。
    background-attachment ：决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。
  - data\*属性配合 js 的用法
    <table id="wosd" data-all="[['名字','年龄','性别'],['Jason','24','men'],['Bob','42','man'],['Merry','32','woman']]">
      <script>
          let res = document.getElementById("wosd").dataset.all
      </script>

## CSS3 知识

- 以前对于目前有争议不兼容的属性，不同的浏览器加上不同的前缀，现在这种做法已淘汰
  -ms- 属性：值 IE 浏览器
  -webkit- 属性：值 Chrome 浏览器
  -moz- 属性：值 火狐浏览器
- 对于大型商业网站，pc 端一个网站，移动端一个网站，两个团队开发
  对于简单的网站只用一个站点，配合 media query 让站点在不同的设备上展示比较合适

### media query

- media query 语法
  - 使用 link 插入外部样式表
    <link  media="logic media and (expression)">
  - 使用 @import 指令调用外部样式表
    @import url() logic media and (expression)
  - 直接在 css 区域插入
    @media logic media and （expression）{css 语法}
- media query 不会增加选择器的优先级
- @media(max-width:500px){rule} 小于 500px 生效
  @media(min-width:500px){rule} 大于 500px 生效
- 像素比：css 像素比上物理像素。DPR device pixel ratio
  手机上一般为 3，即手机上一个 css 像素对应 3 个屏幕物理像素，更多用 dppx 表示 dots per pixel ratio
  @media media and (resolution:3){css 语法}
- dppx 像素比 dots per px 每像素多少个点
  dpi 英寸比 dots per inch 每英寸多少个点
  dpcm 厘米比 dots per cm 每厘米多少个点

### web font

- @font-face 规则
  @font-face{
  font-family: 字体名字；
  src:local('相对地址')，url('绝对地址') format('字体格式')
  }
  为了更好的兼容各大浏览器，我们一般做多次 @font-face 声明，并且每次声明至少写 3 种字体格式

- 防止页面加载时因为引入 CSS 延时产生的抖动

  - 把第一页的样式放在 html 里面
  - 把 link 标签写在最上面（link 标签可以写在任何位置）

- 好用的图标字体网站
  https://www.iconfont.cn 下载图片格式的图标
  https://fontawesome.com/ 下载 css 文件后引用

### 文本排版

- text-shadow: 文本阴影 和 box-shadow 类似
  （x 偏移，y 偏移，模糊半径，颜色）可写多组数值来表现多重阴影，每组值用逗号隔开；
- resize:horizental/vertical/both/none 设置元素大小能否被鼠标控制拉伸，只控制自己，不递归控制
- word-wrap:normal/break-word 设置长单词能否被折断
- text-wrap ：normal（默认）/none 设置文本行能否被折断，none 表示所有文本行写作一行
- text-indent 属性 规定了 一个元素 首行 文本内容之前应该有多少水平空格。
- white-space：nowrap 设置文本内容不折行
  white-space：pre 空白符会被保留。在遇到换行符或者<br>元素时会换行；配合伪元素的 content："/A" 可以使伪元素换行
- text-overflow:ellipsis 文字溢出后显示为省略号
- word-space:12px; 设置行内元素之间的间距
  word-break:break-all 指定了怎样在单词内断行
  word-wrap（overflow-wrap）:break-word 当一个单词一整行都显示不下时，会拆分换行该单词换行

### 移动端的适配方法

- <meta name="viewport"  content="width=device-width" >  利用 px 开发
  <meta name="viewport"  content="width=360" >可以个定值 ，不需要单位 。
  让手机浏览器以多少宽度的初始快包含块来渲染页面，如果不加这个标签，手机会以宽度 1000px 左右包含块来渲染页面，目前移动端流行为 360；
- 所有布局宽高都使用 vw，这样布局的视觉效果和移动端的具体宽度无关了
- 使用 rem 单位； 等比适配，
  1rem=100a
  设置 x*a=100vw;
  x 为视觉口的宽度（开发时设计人员给的值），100vw 是移动端的宽度，可以用 js 直接测出来，这样就可以算出 rem 的值，所有布局宽高都使用 rem 为单位；
  一般 rem 默认最小为 12px, 上面算出的 a 比较小，所以我们一般乘以 100 倍来表示新的 rem, 即 1rem=100*100vw/x , 然后将量出的视觉稿布局尺寸 y 除以 100 即可，那么对应的屏幕布局尺寸
  z=y/100 _ 100a=y/100 _ rem

\*总结
移动端布局：
viewport 标签仅被移动端浏览器支持
PC 端浏览器的渲染窗口即为窗口大小减去额外浏览器自身元素
如果没有 viewport 标签，移动端浏览器会主以 980 像素的浏览器窗口渲染页面（即手机浏览器宽度为 980px)
如果有，如果 viewport 写为 width=X，则移动端浏览器就以 Xpx 为初始包含块渲染页面
如果写为 width=device-width，则移动端浏览器会以出厂设置的宽度为初始包含块的宽度渲染，出厂设置的值一般来说与屏幕物理尺寸正相关，范围一般为 320 到 400 左右，目前最主流的是 360

    假定视觉稿宽度为 X
    对于针对移动端的页面，一般有两种情况：
      *. 页面较复杂，希望页面在不同的手机上效果和比例一致（mi.com 移动端）
        页面需要等比缩放，即视觉稿宽度跟浏览器 / 手机屏幕一样宽
        且我们希望从视觉稿里测量出来的数据能直接用在代码里
      - 所有用户的设备都支持设定视口宽度的产品来说，直接把视口宽度设置为视觉稿宽度，页面使用 px 为单位开发，数值直接从视觉稿量出来
         如<meta name="viewport"  content="width=360" >
      - 对于并不是所有用户的设备都支持设定视口宽度的产品来说，我们同样希望视觉稿里测量出来的数据可以直接用在代码里，于是要找一个可以灵活缩放的单位（因为不同的手机窗口宽度不一样），让 X 倍的这个 单位正好等于宽屏宽度
        Xrem = 100vw
        rem = (100vw / X)
        html {font-size: calc(100vw / X)}
        有些浏览器不允许最小字号小于 12px，而上面的公式算出来的值过小，会被重置，所以将其放大 100 倍，即
        html {font-size: calc(100vw / X * 100)}
        还有些浏览器不支持 calc/vw，所以这个值通过 js 读取出浏览器视口的宽度并自行算出，然后设置到 html 元素上
        之后从视觉稿量出来的尺寸将小数点移动两位后加 rem 单位即可用在代码里。
    
    *. 页面较简单，希望页面在更大的手机上显示更多的内容（github 移动端）
        直接使用 device-width 且使用 px 以及流式布局（块元素自动占满宽度）
    
    *. 对于杂合形页面，即布局复杂，又有很多文字
        布局使用 rem，文字使用 px，width=device-width

### 多列

- column-count:2/3; 设置文本分成多少列，和 column-width 一起用时表示最大多少列
  column-width：150px； 每列的最小宽度
  column-count，column-width 一起使用时，先满足 column-width 的要求，
- column-gap：2em ; 每列之间的间隙
  column-rule: 2px solid red ; 设置每列之间的垂直分隔线
- column-fill：balance（默认值）/auto ; 设置填充方式
  balance 表示每列平均填充文本；auto 表示按照顺序填充，一列填满后再填下一列
- break-inside:avoid-column; 使同一个元素在一列中显示，不要左右断开显示
- column-span：1/all;
  默认值为 1，使行内元素可以分列；值为 all 时，行内元素占据整行不分列；
- 多列属性元素的行内子元素无法撑开其宽度，父元素的宽度为行内子元素不分列时的宽度。

### 边框及边框效果

- border-radius:x1 x2 x3 x4/y1 y2 y3 y4
  border-top-left-radius:x1 y1
  border-top-right-radius:x2 y2
  border-bottom-left-radius:x3 y3
  border-bottom-left-radius:x4 y4
  表示正圆形时 x 和 y 的值一样，写一个值即可；border-radius：x1 x2 x3 x4
  border-radius：9999px, 值足够大就是 4 个圆角（上下或者左右角半径之和大于边框长宽时会等比缩小）
  border-radius：100%， border-box 不为正方形时，为椭圆（百分比是以边框为基础的）
- box-shadow ：/_ inset（向内扩散，不写就默认向外扩散） | x 偏移量 | y 偏移量 | 阴影模糊半径| 阴影扩散半径 | 阴影颜色 _/

### 颜色和透明度

- opacity ：0~1 透明度 \*不能继承，父子元素都有透明度时，先将子元素透明好，再透明父元素，父子元素的透明度在子元素的位置会叠加
  - 会通过触发图形加速，单独形成一个图层和当前图层重合，默认通过图形加速的图层会盖住常规流。比如浮动元素 opacity 属性触发图形加速后会盖住常规流。
  - 通过触发图形加速单独形成一个图层在显卡中进行图形变换，这样工作效率高，效果好。

### 渐变

- linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于<gradient>数据类型，是一种特别的<image>数据类型。
  background-image：linear-gradient(to left ,white,black) 由白到黑向左边渐变
  linear-gradient（渐变方向，可以为弧度角度 ， 开始颜色 ， 结束颜色）
- radial-gradient() 径向渐变；颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值。
- 重复渐变；重复多次渐变图案直到足够填满指定元素。由 repeating-linear-gradient() 和 repeating-radial-gradient() 函数产生。

### 2D 变换

- 先布局再变换
- 线性变换，有规律可循；默认 x 轴箭头向右，y 轴箭头向下
- transform：function（value）function（value）function（value）
  - 变换的元素会通过显卡 (GPU) 渲染，单独形成一个图层，覆盖常规流，但是常规流只能感受它变换之前的位置，无法感知现在的位置，不影响常规流布局
  - 第一个函数变换后，以更新后的位置为基础进行下一次函数变换
  - transform 里面变换前后函数的数量和顺序一样时，不是起点和终点的直线变换，而是按照每个变换点一步一步的渐进变换
- transform-origin：不动点，元素围绕改点进行变换
  - 默认值为元素水平垂直的中点，注意此时其坐标不是（0,0）
  - （0,0）坐标在元素左上角
  - 表达方式
    transform-origin：x, y
    transform-origin：100%, 100%
    transform-origin：left, top
    transform-origin：center, center
- transform:rotate（度） 旋转 ；元素坐标系跟着旋转
- transform:translate（）平移；会把不动点一起平移
  - transform:translate（x, y）
    transform:translatex
    transform:translatey
  - 水平垂直居中
    - 先绝对居中到父元素的中心（top：50%；left：50%）
      再向上和向左平移自身的 50%（ transform:translate（-50%, -50%））
- transform:scale() 缩放，会把自身的坐标缩放
  - transform:scale(x,y) 分别在水平垂直方向缩放
    只有一个值时，x 和 y 共用这一个值
- transform:skey() 倾斜坐标轴一定的角度
  - transform:skey(x , y)
- transform：matrix() 矩阵变换
  所有的变换最终都是综合为一个矩阵变换

### 3D 变换

- 先布局再变换
- transform-origin：x,y,z; 设置不动点的位置
- transform-style：flat（默认值，平面拉伸）/preserve-3d（设置该值有 3D 深度感）
- Perspective 景深，眼睛离平面的垂直距离，可以继承，近大远小；
  transform：perspective（1000px/none），值为具体数值或者 none；该函数只能写在最前面，写在后面会被忽略；
  perspective-origin：x,y; 设置观察点相对于平面的位置
- transform:rotateX/Y/Z()
  transform:rotate3d(x,y,z, 度数）; (x,y,z) 表示矢量坐标，元素围绕该矢量线旋转
- transform:translateX/Y/Z()
  transform:translate3d(x,y,z)
- transform:scaleX/Y/Z()
  transform:scale3d(x,y,z)
  z 的值默认为 0，不设置 Z 的值就相当于进行 2D 变换
- transform：matrix3d() 3D 矩阵变换
  所有的 3D 变换最终都是综合为一个 3D 矩阵变换

### 过度与动画

- transition 平滑的改变 CSS 的值 （可以简写，保证 duration 在 delay 前面即可）
  - transition-property
    指定过渡的属性值，比如 transition-property:opacity 就是只指定 opacity 属性参与这个过渡。默认值为 all
  - transition-duration
    指定这个过渡的持续时间
  - transition-delay
    延迟过渡时间，双向的，开始动画之前和动画结束之后都是有 delay 时间
  - transition-timing-function
    指定过渡动画缓动类型，有 ease | linear | ease-in | ease-out | ease-in-out | step | cubic-bezier() 贝塞尔曲线
    其中，linear 线性过度，ease-in 由慢到快，ease-out 由快到慢，ease-in-out 由慢到快在到慢。
- animation 动画（可以简写，保证 duration 在 delay 前面即可）
  - @keyframes name {关键帧（10%）{属性：值} 关键帧（10%）{属性：值} 关键帧（10%）{属性：值}}
    —关键帧可以用百分比，也可以用 to(100%) 和 from（0%）
  - animation-name：关键帧前面定义的 name
  - animation-duration : 持续时间
  - animation-timing-function 关键帧的过度动画缓动类型
  - animation-delay 动画延迟
  - animation-iteration-count 动画执行次数 默认为 1 次，infinity 表示无数次
  - animation-direction:normal（默认值，1 次播完突变回来）/alternate（表示动画会反着播放回来，1 次结束后不会突变回来，并且回来的这次也算次数）
  - animation-fill-mode: 设置 CSS 动画在执行之前和之后如何将样式应用于其目标。
    -none 当动画未执行时，动画将不会将任何样式应用于目标，而是已经赋予给该元素的 CSS 规则来显示该元素。这是默认值。
    -forwards 目标将保留由执行期间遇到的最后一个关键帧计算值。
    -backwards 动画将在应用于目标时立即应用第一个关键帧中定义的值，并在 animation-delay 期间保留此值。
    -both 动画将遵循 forwards 和 backwards 的规则，从而在两个方向上扩展动画属性
  - animation-play-state: 动画播放状态 running（播放）/paused（暂停）

### Blend Modes/Filter/Masking

- background-blend-mide 设置背景的颜色混合方式
  mix-blend-mide 设置多个元素的颜色混合方式
  isolation：auto/isolate 该属性的主要作用是当和 background-blend-mode 属性一起使用时，可以只混合一个指定元素栈的背景
  - filter 滤镜
    filter: blur(5px); 模糊
    filter: brightness(0.4); 亮度
    filter: contrast(200%); 对比度
    filter: drop-shadow(16px 16px 20px blue); 阴影效果
    filter: grayscale(50%); 将图像转换为灰度图像
    filter: hue-rotate(90deg); 给图像应用色相旋转
    filter: invert(75%); 反转输入图像。值定义转换的比例。100% 的价值是完全反转。值为 0% 则图像无变化。
    filter: opacity(25%); 转化图像的透明程度
    filter: saturate(30%); 转换图像饱和度。
    filter: sepia(60%) 将图像转换为深褐色
  - mask 允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。

### Flex 布局

- 知识来源： http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html
- 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。任何一个容器都可以指定为 Flex 布局，行内元素也可以使用 Flex 布局；
  它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。 设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。
- 相关概念：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。
- flex 也是在常规流的布局，当元素设置 flex 布局时，先进行常规流布局，再在此基础上拉伸

#### Flex 的相关属性

- flex container 相关属性
  - diplay:flex; 初始必要设置
  - flex-direction 属性决定主轴的方向（即项目的排列方向）
    - row（默认值）：主轴为水平方向，起点在左端。
    - row-reverse：主轴为水平方向，起点在右端。
    - 当主轴为水平方向时，item 的 height 默认值为 100%；
    - column：主轴为垂直方向，起点在上沿。
    - column-reverse：主轴为垂直方向，起点在下沿。
    - 当主轴为垂直方向时，item 的 width 默认值为 100%；
  - flex-wrap 属性定义，如果一条轴线排不下，如何换行。
    - nowrap（默认）：不换行。
    - wrap：换行，第一行在上方。
    - wrap-reverse：换行，第一行在下方。
  - flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap
  - justify-content 属性定义了项目在主轴上的对齐方式。
    - flex-start（默认值）：左对齐
    - flex-end：右对齐
    - center： 居中
    - space-between：两端对齐，项目之间的间隔都相等。
    - space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
  - align-items 属性定义项目在交叉轴上如何对齐。
    - flex-start：交叉轴的起点对齐。
    - flex-end：交叉轴的终点对齐。
    - center：交叉轴的中点对齐。
    - baseline: 项目的第一行文字的基线对齐。
    - stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。
  - align-content 属性定义了多根交叉轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
    - flex-start：与交叉轴的起点对齐。
    - flex-end：与交叉轴的终点对齐。
    - center：与交叉轴的中点对齐。
    - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
    - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
    - stretch（默认值）：轴线占满整个交叉轴。
- flex item 相关属性
  - order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
  - flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
    - 所有 item 的 flex-grow 的值之和大于 1 时，所有的剩余空间按照值的比例分配。
    - 所有 item 的 flex-grow 的值之和小于 1 时，每个 item 分配到的剩余空间为总的剩余空间乘以 flex-grow 的值，即有部分剩余空间没被分配
  - flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。
    - 空间不足时该属性才生效，负值对该属性无效；
    - item 缩小的权重是 其宽度（高度）乘以 flex-shrink 的值 ，缩小的距离即为该 item 所占的权重比例乘以整体的缩小距离；
      eg: [(300*2)/（400*3+300*2+500*4)](权重比例)\*200(整体的缩小距离)
  - flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小；
    根据主轴的方向，flex-basis 分别对应在 width 和 height；
    flex-direction 为 row 时，flex-basis 为 width
    flex-direction 为 column 时，flex-basis 为 height
  - flex-basis 不为 auto，值为具体值时，flex-basis 的优先级比宽高的优先级高 (flex-basis:100px; width:200px，前者生效）
    flex-basis:auto 时， flex-basis 的优先级比宽高的优先级低 (flex-basis:100px; width:200px，后者生效）
  - flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。
  - align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。

### 水平垂直居中知识汇总

- 以下父元素称为包含块，子元素称为内容区
- 包含块的 line-height=height 时，实现文字的垂直居中。内容区和行高共用一条居中线，当行高等于行框高度时，行高的中点也就是行框的中点；
- 包含块 text-align=center，使其内容区水平居中。
- 包含块内容区 margin=auto 时，实现水平居中；
- 行内元素 vertical-align=middle, 加上 font-size：0，可以实现垂直居中。
  字符 X 在父元素中并不一定是垂直居中的，各个字体的字符 X 的高低位置不一致。所以，当字体大小较大时，这种差异就更明显。而当字体大小为 0 时，基线的位置就等于中线的位置，我们通过设置父元素的 font-size:0 来使图片达到完成垂直居中的效果 ；
- 绝对定位时，设置内容区的上下左右都为 0，margin 为 auto 时也可以实现水平垂直居中；margin 在这种情况下会自动调整，上 margin 等于下 margin。左 margin 等于右 margin
- flex 布局时，justify-content=center，align-items=center 可以实现水平垂直居中
- 利用表格时，为 td 设置 text-align 为 center ,vertical-align: middle 可以水平垂直居中；
  td 里面的内容默认是垂直居中的，可以省略 vertical-align: middle
- 利用 translate 平移属性
  先绝对居中到父元素的中心（top：50%；left：50%）
  再向上和向左平移自身的 50%（ transform:translate（-50%, -50%））

### Sass

- 更多知识 http://www.ruanyifeng.com/blog/2012/06/sass.html
- sass 转化为 css 网站 https://www.sassmeister.c`om/
- 类似于根一样的嵌套规则，@import 命令，用来插入外部文件。如 @import "path/filename.scss";
- & 符号表示父选择器，可直接使用
- 变量 $ , 变量仅在它定义的选择器嵌套层级的范围内可用，加上！globle 就是全局属性；
    　　$blue : #1875e7;
  　　 div {
  　　　 color : \$blue;
  　　}
- 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。
  　$side : left;
    　　.rounded {
    　　　　border-#{$side}-radius: 5px;
    　　}
  - 循环语句编辑（through 包括最后一位，to 不包括）
    下面表示子元素第 1 到第 9 个 span 的宽度为等差数列（20px, 40px, 60px....180px)
    　@for $i from 1 to 10{
            span:nth-child(#{$i}){
    width:\$i \* 20px;
    }
    }

# Bootstrap(CSS 框架）

- 直接用 link 引入<link href="url" rel="stylesheet" type="text/css"   integrity="完整性验证码（HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu）" >

# 布尔代数与逻辑电路

## 布尔代数

### 布尔代数其实就是命题逻辑的【形式化表达】

- 命题逻辑
  _ 真命题
  _ 假命题
  _ 逆命题
  _ 否命题 \* 逆否命题等

- 布尔代数中只有两个值，即真和假，一般表示为 0 和 1，对应于命题逻辑里命题的真和假
- 当使用变量表示值的时候，一般使用【大写】的单个字母，如 A，B 等
- 布尔代数中的两个值可以进行如下简单的【基本运算】
- 逻辑与
  _ 0 & 0 = 0
  _ 0 & 1 = 0
  _ 1 & 0 = 0
  _ 1 & 1 = 1
- 或
  _ 0 | 0 = 0
  _ 0 | 1 = 1
  _ 1 | 0 = 1
  _ 1 | 1 = 1
- 非
  _ !0 = 1
  _ !1 = 0

- 常见非基本运算：
  _ 异或
  相同为 0，不同为 1
  _ 0 ^ 1 = 1
  _ 1 ^ 0 = 1
  _ 0 ^ 0 = 0
  _ 1 ^ 1 = 0
  _ 同或
  相同为 1，不同为 0
  _ 异或的反运算
  _ 0 ^ 1 = 0
  _ 1 ^ 0 = 0
  _ 0 ^ 0 = 1
  _ 1 ^ 1 = 1
  _ 与非
  _ 先与后非
  _ 0 NAND 0 = 1
  _ 0 与非 1 = 1
  _ 1 与非 0 = 1
  _ 1 与非 1 = 0
  _ 或非
  _ 先或后非
  _ 0 或非 0 = 1
  _ 0 或非 1 = 0
  _ 1 或非 0 = 0
  _ 1 或非 1 = 0
  _ 理论上，所有的逻辑运算都可以仅通过与非运算表达 \* https://zh.wikipedia.org/wiki/%E4%B8%8E%E9%9D%9E%E9%97%A8

- 逻辑非的多种表达方式：
  _ V + 表示或 A+B
  _ 反 V AB 表示与 AB \* 值上方加一横、或者 A'、或者！A、或者﹃A，表示非 A
- 通常为了方便表达、理解和书写，纯文本表达时，用加号（+）表示或，用乘号（\*）表示与（有时为了方便也可省略点乘号直接写成 AB），用叹号或单引号（!，'）表示非：A'，!A。手写时用上方加横表示非

- 常用运算法则（通过集合是思想去理解）
  _ 幂等律
  _ A + A = A
  _ A _ A = A
  _ 有界律
  _ A + 0 = A
  _ A _ 1 = A
  _ A _ 0 = 0
  _ A + 1 = 1
  _ 交换律
  _ A + B = B + A
  _ AB = BA
  _ 结合律
  _ A+B+C = A + (B + C) = (A + B) + C
  _ ABC = A(BC) = (AB)C
  _ 还原律
  _ A = !!A
  _ 摩根定律 / 反演律
  _ !(A _ B) = !A + !B
  _ !(A + B) = !A _ !B
  _ 分配律
  _ A _ (B + C) = (A _ B) + (A _ C)
  _ A + (B _ C) = (A + B) _ (A + C) \* 其它 http://blog.csdn.net/yueniaoshi/article/details/8040119
- 逻辑表达式的真值表
  _ 即把一个逻辑表达式的【所有变量的所有可能】及【此时表达式的值】全部列出来的一张表
  _ A _ B = ？
  _ 0 0 0
  _ 0 1 0
  _ 1 0 0
  _ 1 1 1
  _ 例：
  _ 用真值表证明前面各个运算法则
  _ 反演律 也可以通过真值表反推运算规律 \* 分配律
- 逻辑函数
  _ 由逻辑变量组成的表达式的值
  _ F = A _ B + C
  _ F(A,B,C) = A \* B + C
- 如何由真值表反推出逻辑函数
- 如何化简逻辑函数
- 卡诺图
  _ 有时真值表写成一列比较麻烦
  _ 我们可以把真值表写成二维的
  _ 卡诺图真正的目的是为了化简更方便
  _ 例

# 逻辑电路

- 逻辑电路（logic circuit）由各种逻辑门 (logic gate) 组成
- 逻辑门之所以称为逻辑门，是因为它们可以实现简单的逻辑运算
- 逻辑门是如何组成的？
  _ 继电器
  _ 真空管
  _ 晶体管
  _ 三极管 \* PN 结
- 基本的逻辑门有三种
  _ 与门 (AND Gate)
  _ 或门 (OR Gate) \* 非门 (NOT Gate)
- 复合逻辑门
  _ 异或门 (XOR Gate)
  _ 与非门 (NAND Gate)
  _ 其中仅用与非门即可模拟出所有其它的逻辑门
  _ https://zh.wikipedia.org/wiki/%E4%B8%8E%E9%9D%9E%E9%97%A8 \* 等等
- 如果我们把相应的逻辑运算表达成逻辑函数，然后构造一个与逻辑函数对应的逻辑电路，则该电路即可表达我们的逻辑
- 由此我们可以使用电路实现任意的逻辑，实际上计算机电路中所有的逻辑门也都是用与非门来表达的

# javascript 笔记

## UTF8 编码规则

- 第一个字节前面若干 bit 表示需要几个字节，以 1 开头 0 结尾，没有用到的 bit 位储存数据
  - 11110 开头 需要 4 个字节
  - 1110 开头 需要 3 个字节
  - 110 开头 需要 2 个字节
  - 0 开头 需要 1 个字节 和 ASCII 规则一致
- 第二个字节开始以 10 开始 ，后面的 6 位储存数据
  - 11110 开头 11110--- 10------ 10------ 10------ 21 个 bit 储存数据
  - 1110 开头 1110---- 10------ 10------ 16 个 bit 储存数据
  - 110 开头 110----- 10------ 11 个 bit 储存数据
  - 0 开头 0------- 7 个 bit 储存数据
- 字符数据填入方式
  - 字符对应的 Unicode 编码转化为 2 进制，2 进制从左往右，依次从左边开始填入到存储数据的 bit 位上
  - 如 128523 转化为 2 进制 1 1111 0110 0000 1011 ，一共需要 17 个 bit 位，需要 4 个字节
    所以填入方式为 11110000 10011111 10011000 10001011 前面没填满的数据字节补零
- 变长编码，根据符号所需字节的大小调整编码长度，可以节省字节储存空间
- 兼容标准 ASCII，当字符只需要 1 个字节时，以 0 开头
- 容错 第二个储存字节开始都是以 10 开头，计算机可以识别出是否有字节丢失，最小的减少损失

## 整数在计算机中的表示和运算

- 整数在计算机中的表达类似于时钟表盘。如对于表盘来说，向前拨动 3 个刻度的指针，相当于向后拨动 9 个刻度的指针；反过来，向后拨动 5 个刻度相当于向前拨动 7 个刻度，于是减 5 就可以转换为加 7，于是 -5 用 7 来表达，二进制中也只是周期不一样，周期为 2 的 n 次方，最高位 1 表示负数，0 表示正数；
- 原码 1101 12568
  反码 0010 87431
  补码 0011 87432
  补码 = 周期 - 原码
  为了计算方面，通过周期 -1- 原码 +1 的方式计算补码（这样做减 ��� 不会借位，计算机 ��� 通过这样求反码的）
  或者通过（周期 -1）-（原码 -1）的方式计算补码（结果一样，思路不一样）
- 位运算符
  - 其它基本类型参与位运算时也会先转换为 number 类型
  - 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分
  - js 语言中的整数在参与位运算时用 4 个字节表示，即 32bit
  - 如果整数部分超出 4 个字节（溢出），取整数右边 32 位。
    |按位或 2|3=3 双方化为 2 进制每 bit 位进行或运算，任何数和 0 按位或都得到其本身整数部分
    & 按位与 2&3=2 双方化为 2 进制每 bit 位进行与运算
    - n & (n - 1) 把二进制最右边一位的 1 化为 0
      ^ 按位异或
    - 双方化为 2 进制每 bit 位进行异或运算
    - 不同为 1. 相同为 0；
    - 任何数和自身异或都为 0，任何数和 0 异或都为自身； 2^2==0；2^0==2;
    - 两个整数交换的方法
      a = a^b
      b = a^b
      a = a^b
      ~按位非 ~2==-3 数字化为 2 进制每 bit 位进行非运算
      符号》>按位右移（保留符号位） 15>>3==1; n>>1==Math.floor(n/2) n>>2==Math.floor(n/4) n>>3==Math.floor(n/8)
      符号》>>按位右移（不保留符号位，左边补 0） -15>>>3==536870910
      <《按位左移（右边总是补 0） 15<<3==120
- ** 次方 2**5==32
- x.toFixed(n) 可以让 x 保留小数点后 n 位，4 舍 5 入，返回的是一个字符串
- 将其他进制数转化为字符串再转化为 Number 后就变为 10 进制数了
- x.toString().length 可以判断 x 的位数，如果 x 为负值，那么 - 号也要算一位，结果比正常值多 1
  数字直接转化为字符串，需要在数字后面加个。, 在加上 toString 方法；
  123..toString == "123" 第一个。号让计算机确认 123 为数字，第二个。号表示调用 toString() 方法
- 逗号表达式：对它的每个操作数求值（从左到右），并返回最后一个操作数的值
  toolbar = d = a+b,e = 2*d , 3*e => toolbar = 36

## 浮点数在计算机中的表示和运算

- 单精度储存 float 4 个字节 js 中的整数在参与位运算时用 4 个字节储存
  双精度储存 double 8 个字节 js 中的浮点数是用 8 个字节储存，整数也是以浮点数的方式储存；当整数要参与位运算时，将二进制的整数部分右边的 32 位取出，与 0 按位或得到其在 4 个字节时的值；如 Number.MAX_SAFE_INTEGER | 0 = -1 ，Number.MAX_SAFE_INTEGER 在二进制中是 53 个 1，参与位运算时取出 32 个 1 与 0 按位或得到 32 个 1，整数的 32 个 1 在 4 个字节里转化为 10 进制的值就是 -1
- 有符号整数：即有原码和补码的概念，最左边一位表示正负
  无符号整数：没有原码和补码的概念，只能用 +/- 表示正负
  number>>>0 将结果以以无符号整数输出
- js 运算结果以 32 位有符号整数理解，除了》>>运算符，它的运算结果以无符号整数理解
- JS 中浮点数以 8 个字节储存，64 个 bit，以 2 进制的科学计数法储存（整数部分永远转化为 1），形式如下
  - 1bit（符号位） + 11bit（指数位） + 52bit（底数位）
    - （1 + 底数位）\* 2\*\*（指数位）
    - 符号位，占用 1 个 bit ，正数为 0，负数为 1
    - 指数位，占用 11 个 bit，指数大小分布 -1023~1024 之间，分别用 0~2047 来表达，用科学计数法算出的指数 +1023 得出的数值储存在这 11bit 里面，即 -1023 次方在 11bit 里面写作 0,1024 次方写作 2047
    - 底数位，底数小数部分直接填在 52bit 里面
      - 直接填在左边，右边多余的 bit 都填 0
      - 对于无限循环的小数部分（如 0.2），第 53 位如果为 1 就进 1 给第 52 位， 第 53 位如果为 0 直接舍去
  - 这样表示的原因：当比较两个浮点数大小时 计算机从左往右读取数据，读到符号位时，谁是 0 谁大；读到指数位和底数位，谁先遇到 1 谁打大；这样计算机就可 4 以更快判断两个浮点数的大小
  - 因为有的浮点数在计算机里面不够精确，所以一般比较浮点数的大小时用如下方法：
    |a-b|《阈 yu 值 Number.EPSILON 为 true 时 ，我们可以认为 a 和 b 相等
  - 计算机里面 10 进制小数后面的第 16 位开始不够精确，因为计算机的最大精度为 2 的 -52 次方，这个数值在 10^-15 ~ 10^-16 之间，比最大精度还小的数在计算机里面表示不精确
  - number.toPrecision（位数） 浮点数精确到小数点后面多少位时的值
  - 越接近 0 的浮点数越精确，因为底数位一共只有 52bit，转化为 2 进制科学计数法时，整数部分右移，整数部分越大，右移的 bit 位越多，表示小数位的 bit 位也就越少，越不精确
  - NaN +0 -0 Infinity -Infinity 这几个特殊值不符合上面规律
  - 几个常见的 Number 方法
    - Number.EPSILON == 2\*\*(-52) 即 1 和大于 1 的最小浮点数之间的差值 ，<Buffer 3c b0 00 00 00 00 00 00> ， 如果|a-b|< Number.EPSILON，则 a 和 b 相等
      在 0~1 之间，也有比 Number.EPSILON 更小的精度值，比如 Number.Min_value, 但是计算机在此时已经失真，如果|a-b|< Number.EPSILON，也可以近似认为 a 和 b 相等
    - Number.MAX_SAFE_INTEGER == (1 + [1 - 2**(-52)])\* 2**(52) == 2**53 - 1；<Buffer 43 3f ff ff ff ff ff ff>；
      计算机中表示的最大的精确整数，即整数位转化为科学计数法时右移占满 52 个 bit，且每个 bit 值都为 1；
    - Number.Max_value, 表示 js 中最大的正数，<Buffer 7f ef ff ff ff ff ff ff>；即 (1 + (1 - 2**(-52))\* 2**(1023)
      -Number.MIn_value, 来表示 js 中最小的正数，<Buffer 00 00 00 00 00 00 00 01> ; 即 （1 + 2**(-52))\*2**（-1023）, 这个值比 Number.EPSILON 还小，计算机也计算失真
  - <Buffer 7f ff ff ff ff ff ff ff> 这个值没有确定的函数方法，计算是 Infinity
  - 大于 Number.MAX*SAFE_INTEGER 的所有数字可以使用 BigInt 表达；BigInt(1321233123131313312321312n) == BigInt("1321233123131313312321312") ；BigInt(1321233123131313312321312n) * 2n
    BigInt 可以和 +、`_`、`-`、`\*\*`、`%` 一起使用； BigInt 里面和外面是纯数字时数字后面加个 n

## js 编码规范及行业术语

- js 代码是由表达式和语句组成，表达式有求值结果，一般配合 = 使用，语句（var/for/while/if/switch/return/debugger/do）没有求值结果，语句有明确的开始和结束，结束的地方有默认的；号
- js 中回车时解析器会自动加上分号 ，当一行的第一个字符是 +，-，/,[,( 这 5 个字符时，他前面一行必须加分号。
- 比较符》= 或者 <= 之间不能有空格
- top 和 name 是运行环境中默认已经生成的变量，不能用这两个变量名于赋值
- x++ x 自增 1 ，先赋值再自增 ， 即 x++ 的值为 x
  ++x x 自增 1 ，先自增再赋值 , 即 ++x 的值为 x+1
  以上两个运算都会把 x 自动转化为 Number 类型
- polyfill: 在老浏览器里把新浏览器的功能完全实现，如 includes 函数
  shim: 无法在老浏览器完全实现的实现。如 Object.create,Object.defineProperty

## 编程语言知识

- 静态语言 (c/c++/java/typescript): 变量也有类型且只能指向那种类型的值
  动态语言 (js/python/ruby): 变量没有类型但是值有类型，变量可以指向不同类型的值
- 强类型（python/java): 程序运行时值的类型不会自动转换，类型不匹配的运算会报错
  弱类型（c/js）: 程序运行时值的类型可以根据运算符自动转换
- 静态作用域语言（词法作用域）：声明的变量有一个在编译时静态确定的作用域，变量在自己的作用域内可见； 在这段区域以外该变量不可见（或无法访问）；
  动态作用域语言：声明的变量只要有代码访问该变量，该变量就一直存在，变量作用域是动态的；
  现在主流的编程语言都是静态作用域，也有的语言两种作用域都可以兼用
- token 词元的意思，表示代码的最小单位，也有令牌的意思；

## 汇编

- 计算机语言
  机器语言：01001001 这样的机器码；基本不用
  汇编语言：通过指令集来操作机器语言；基本不用
  高级语言：现代编程语言（C/C++/java/js）
  最终都是通过直接或间接操作机器码来实现
- CPU
  - CPU 和内存的连接
    - 地址线：连接目标内存地址的线
    - 数据线：获取目标内存数据的线
  - 指令集（instruction set） 不同的 cup 有不同的指令集（X86,ARM,6502)
    - 指令： 进行简单的运算和逻辑
  - 寄存器 ：CPU 运行时存储缓存数据的空间
- 编译型语言 C/C++ /Rust
  - 将源代码直接转化为机器码，由 CPU 执行
  - 同一个代码只能在同一类 CPU 执行，不能跨平台编译
    解释型语言 JS/Python 需要虚拟机（VM）
  - VM 拿到源代码后先检查语法，然后将代码构建为语法树，编译为机器码
  - 可以跨平台，不需要重新编译
  - V8 引擎 (VM) 的 JIT 优化（just in time） - V8 引擎发现某段代码会大量重复执行时会直接将这段代码转化为机器码
    半编译型语言 JAVA 需要虚拟机（VM）
  - VM 将源代码编译为面向 javaVM 的字节码，字节码不由 CPU 直接执行，而是由专门的 javaVM 执行
  - VM 执行字节码时不用构建语法树执行，直接按照字节码顺序执行
  - 可以跨平台，不需要重新编译
- WASM (Web ASM) 基于 web 的字节码技术，一种标准
  - 直接给浏览器发送字节码来运行，提高性能
  - 可以将其他高级语言转化为 WASM 从而可以开发前端程序

## 字符串

- trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等） 以及所有行终止符字符（如 LF，CR）。
  var orig = ' foo '; console.log(orig.trim()); // 'foo'
- String.fromCharCode(Unicode 码） 将 Unicode 码 转化为对应字符
- String.charCodeAt（索引） 将第几个字符转化为 Unicode 码
- String.repeat() "x".repeat(2)=>"xx"
- String.endsWith(value) 字符串是否以 value 结束
- String.split() 将字符串转化为数组
- String.raw`templateString` String.raw() 是一个模板字符串的标签函数，是用来获取一个模板字符串的原始字符串的；templateString: 模板字符串，可包含占位符（\${...}）

## 数字

- Number.isNaN // 仅 NaN 返回真
  window.isNaN // 不是数值都返回真（NaN 返回真）

## 作用域

- js 只有函数才能创造作用域；调用函数时要回到创造函数的位置调用，函数里面变量的值不会因为调用函数的位置而发生改变，其初始值是固定的
- 内部作用域可以读取外部作用域里面的变量，外面的作用域不能读取内部作用域里面的变量
- 在任何作用域里面写有一个不用 var 声明的赋值表达式，f = 2 , 那么该变量相当于一个全局变量，相当于 window.f = 2
- 用 let 声明的变量相当于声明了一个块级作用域，即只在离它最近的语句块{}里面生效，外面的语句块无法访问；块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。
- 用 var 声明的变量会提到 var 所在函数作用域的最前面，但是不赋值，到了赋值那一行才赋值
  用 let 声明的变量不会提前，在那行声明就在那行赋值；但在该作用域中，声明完成之前不能使用该变量，以及外部作用域的同名变量，称为 TDZ Temper Dead Zone 暂时性死区；而且在同一个块级作用域里面同一个变量只能用 let 声明一次；
  var a = 8
  {
  console.log(a)
  let a = 9
  } 不会输出 a, 会报错
  const 声明和 let 声明一致，此外 const 声明的变量是一个常量，变量的指向不能改变，如果变量指向一个对象，对象里面的内容可以变；同一个变量只能用 const 声明一次；
- 用 let 和 const 在全局作用域声明的变量也不能通过 window. 属性访问到
  window.length 返回页面中框架的数量（元素 frame 和 iframe）
- 函数的【function 函数名{}】形式定义在 js 中也会提前赋值，会提到函数所在函数作用域的最前面
  函数的【var 函数名 = function{}】形式也会提前声明，但不不赋值，到了赋值那一行才赋值

## 闭包

- 可以访问其他函数内变量的函数，叫做闭包。
- 闭包可以理解为作用域嵌套。作用域里面的函数要访问作用域里面的变量，作用域不能销毁，作用域里面的函数在调用时会产生新的作用域，嵌套在当前作用域里面；
- 函数运行时创建作用域，函数结束时作用域不一定销毁；函数不产生闭包会在结束时销毁；如果还有代码使用作用域里面的变量值，产生了闭包，作用域不会销毁，里面的变量值还是可以被调用它的函数使用；
- 函数本身处在哪个作用域（A），它运行时创建的作用域（B）就在哪个作用域（A）内部；函数本身也是处于一个作用域的。是创建它的函数运行时所创建的作用域。

## 栈

- 单边进，单边出；后进先出，先进后出
- 调用栈：函数遇到其内部函数时先会进入到内部函数里面执行内部函数的代码，等到内部函数的代码执行完毕，再接着执行下面的代码；这种逻辑结构就是调用栈；
- 调用栈的深度：函数的内部函数的内部函数的内部函数这种调用方式体现了调用栈的深度，即函数展开的层次；如果调用栈超过了其深度会发生栈空间溢出；
- 调用栈不一定产生闭包，因为兄弟函数之间也可以互相调用，此时他们共用一个父函数的作用域
- 调用栈展开的层次也是一种树状结构

## 函数

- 副作用：打印了一段输出或者修改了全局变量
  返回值：纯函数，通过参数产生值，不读取全局变量，值仅由其参数决定
- ducument.write() 向文档的解析流里写入内容，文档一解析完</html>，解析流关闭；重新 document.write 会导致重新打开一个解析流，之前 html 的内容会被冲掉，js 运行后创建的函数及变量是没有冲掉的
  ducument.open() 打开解析流，打开页面时默认打开
  ducument.close() 关闭解析流，关闭页面时默认关闭
- 形参 ：函数定义的参数
  实参 ：函数实际传递的参数
- 函数的相关方法
  fun = function(){}
  - fun.apply(null,array) ==fun(...array)
    将数组里面的参数一次性传递给函数
  - fun.length =>形参的个数
  - fun.toString() 函数的源代码
  - fun.name =>函数的名字

## JSON 一种数据格式

- 一段储存数据的字符串，写法类似 js 的数据格式
  https://www.json.org/json-zh.html 每种 js 值对应着每种 json 结构
  JSON.stringify(value[, replacer [, space]]) =>JSON 格式
  JSON.parse(text[, reviver]) =>值
- JSON 里面的属性名都要加双引号，属性值不能是表达式，只能是最终结果
- 双引号之间不能有特殊字符（需要转义 \\t )，不能出现任意的多余逗号，不能有 undefined 值
- 序列化：比如链表结构在储存时会转化为一种其它的数据格式（如 json), 该结构是连续储存的，这就是序列化
  反序列化：比如链表结构在运行中就是反序列化的，不同的节点在不同的内存中，不连续储存
- 利用 JAON 进行深拷贝 JSON.parse(JSON.stringfy())
  使用这种方法会有一些隐藏的坑：因为在序列化 JavaScript 对象时，所有函数和原型成员会被有意忽略。
  通俗点说，JSON.parse(JSON.stringfy(X))，其中 X 只能是 Number, String, Boolean, Array, 扁平对象，即那些能够被 JSON 直接表示的数据结构。
- JSON.stringify(一个 promise)=>{}
- 环形克隆
  function cloneDeep(obj) {
  var cacheMap = new Map()
  return clone(obj)
  function clone(obj) {
  if (cacheMap.has(obj)) {
  return cacheMap.get(obj)
  }
  var ret = {}
  cacheMap.set(obj, ret)
  for(let key in obj) {
  let val = obj[key]
  if (typeof val == 'object') {
  ret[key] = clone(val)
  } else {
  ret[key] = val
  }
  }
  return ret
  }
  }

## Debug

- debugger 在调试代码最前面加一个断点 debugger；
- 在 sources 栏里面鼠标指定断点位置；
- google 同一时间同一个页面只能 debugger 一个地方
- 在 sources 栏里面 snippet 选项里可以执行代码（Ctrl + enter），也可以格式化代码
- try{throw }catch(e){}finally{}

  - 在一段代码可能有异常时使用
  - try 是必要语句，后面两个至少需要一个
  - 如果整体代码有语法错误，则所有的代码都不会执行
    因为 js 代码的启动有以步骤：
    词法解析
    语法解析
    执行
  - try 语句：里面是填写 js 代码，
    - 里面可以接 throw 语句，抛出自己填写的报错信息（一般抛出 throw new Error(""))，并且 try 里面的执行语句终止，catch 的变量 e 会接收这个错误；throw 会在离自己最近的 try 语句中生效
  - catch: 如果 try 语句里面有错误，catch 会返回错误的具体信息；需要一个变量 e 来接收错误，e 只在自己的 catch 语句中生效
    变量 e 有几个属性，e.stack 调用栈信息；e.message 具体的错误原因；e.name: 错误类型函数
  - finally：里面的代码永远可以运行，不管前面有没有错误
  - function hasValue(root, val) {
    try {
    traverse(root)
    return false
    } catch(e) {
    if(e===true){
    return true
    }
    return e
    }
    function traverse(root) {
    if (root) {
    if (root.val == val) {
    throw true
    }
    traverse(root.left)
    traverse(root.right)
    }
    }
    }

- 严格模式：在作用域的顶部写上"use strict" 该作用域里面的代码就可以按照严格模式执行；但是并不能要求作用域里面嵌套的作用域按照严格模式执行；
  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode
  在严格模式下，以纯函数形式调用函数时，this 不是 window，而是 undefined
  在严格模式下禁用了一些本身就有问题的语句（如 with 语句）
  在严格模式下函数不能有重复的形参
  严格模式 8 进制以 0o 开头，不能以 0 开头，会报错
  严格模式不能给原始数据类型添加属性，会报错
  严格模式下 eval 语句不能为上层范围 (surrounding scope, 注：包围 eval 代码块的范围）引入新变量，只能在 eval 语句内部自己用；
  一些 ES6 语法自带严格模式，如 class
- eval 语句是将字符串当做代码解读，如 eval("'use strict'; var x = 42; ")
  eval 具有动态作用域的特性，可以访问调用位置的变量
  eval 换个名字就会变成全局方法； run = eval ; run("console.log(a)") ; run 只会读取全局变量 a，而不读取局部的 a
- 测试框架： describe 函数

## 对象

- 数组是值的有序集合
  对象是值的具有名字的集合
- 对象的相关方法

  - Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致。
  - for in 的迭代顺序
    - 先按照大小顺序迭代整数属性名
    - 之后迭代其它属性，按照添加顺序
  - Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）, 这个方法也可以用于数组和字符串
    const obj = { foo: 'bar', baz: 42 };
    console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]
  - Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
    const target = { a: 1, b: 2 }
    const source = { b: 4, c: 5 }
    const returnedTarget = Object.assign(target, source)
    console.log(target) =>{ a: 1, b: 4, c: 5 }
    console.log(returnedTarget) => { a: 1, b: 4, c: 5 }
    -Object.getOwnPropertyDescriptor(obj, propertyName)
    返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）

- 当一个对象和原始数据类型==对比时，会调用对象上面的 valueOf 方法,其返回值进行对比

- null 和 undefined 没有属性，其它所有数据类型的值都有属性
- 包含函数的属性称为某个值的方法
- obj【表达式】：表达式的返回值作为对象选中的属性名，也可以传递一个变量；obj【变量】
  object.property
  object['property'] 注意里面是个字符串
- 现代引擎中，关键字 / 数值 做为对象属性名也可以不加引号
  { 1:2, 0: 3, for: 8, while: 9, foo: 10, "2abc": 3, 'hello world': 9}
- 用 == 或者 === 判断对象是否相等时，只有两个对象都指向同一个内存地址的对象实体才为 true，其它的即使两个对象内容，值一样但是指向的对象实体不一样会返回 false；
  而原始数据类型 Number ，String，Boolean 作相等比较时只比较值，而不管指向地址
- obj1 = obj2 这句代码是使 obj1 指向 obj2 的对象实体，所以 obj1 === obj2；这种情况改变对象实体里面的内容，两个对象都发生了改变
- 原始数据类型 Number，String，Boolean 的值是固定的，不能再添加属性，但是添加了也不会报错
- 原始数据类型 Number，String，Boolean 直接当做对象来添加属性"XX"时，会短暂的生成一个新的对象 A, 在 A 中添加属性"X"，之后 A 会被清理掉；当要读取这个添加的属性"X"时，又会短暂的生成一个新的对象 B, 在 B 中读取属性"X", 返回 undefined，之后 B 被清理掉；
  如：123.ab = 1 会在 A 对象中添加 ab 属性，之后消失
  console,log(123.ab) 会在 B 对象中寻找 ab 属性，返回 undefined
- 包装对象：1 个真实的对象包装了一个原始数据，如 Objiect() 函数强行将其他类型转化为对象； Object(1);Object("123"})
  原始对象 / 原生对象：直接声明的对象 ；asd = {}
- 全局作用域中只有一个全局对象 window, 所有的全局属性都在 window 对象里面，window 对象的任何属性都指向属性本身，window 对象的 window 属性指向 window 对象本身
  window.window===window
  window.console===console
- 对象的浅对比：=== 是作浅比较，只检查左右两边是否是同一个对象的引用
  对象的深对比：不仅是同一个对象的引用，而且是同一个链表

## 数组

- 判断两个纯数字数组里面的内容是否相同，先 array.sort(function(a,b){return a - b}) 从小到大排序，再 join() 转化为字符串作全等判断
- 数组相关方法
  - arr = Array.from(arrlike) 从一个（类似）数组或可迭代对象中创建一个新的，浅拷贝的数组实例
  - Array.isArray(arr) 判断 arr 是否是数组
  - arr.fill(value ，start，end) 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。
  - arr.flat(depth) flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中 的元素合并 为一个新数组返回；depth 默认 1
  - arr.includes(value) 方法用来判断一个数组是否包含一个指定的值，也可以判断是否有 NaN，根据情况，如果包含则返回 true，否则返回 false。注意：对象数组 [{},{}] 不能使用 includes 方法来检测。
  - arr.indexOf() 返回下标，不能判断 NaN，会返回 -1
  - find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。
    findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回 -1。
  - reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。
  - some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值。
    every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。
  - 数组的 toString 方法[1,2,3].toString()=>'1,2,3'
- ES6 数组去重的最佳实践：Set 结合 Array.from()
  var a = [1,1,2,2,4,4]
  var b = new Set(a)
  var c = Array.from(b) =>[1,2,4]
  var d = b.size =>3（不同项个数）
- 数组的高阶函数作为方法调用时（each,map,every 等等）, 可以加一个参数表示为第一个参数的他 this
  [1,2,3].map(f(),obj)=>obj 是 f() 的 this
- 数组的冒泡排序最优解 每次把最值放到最后
  function swap(ary, i, j) {
  if (i != j) {
  var t = ary[i]
  ary[i] = ary[j]
  ary[j] = t
  }
  }
  function bubbleSort(ary) {
  for(var j = ary.length - 2; j >= 0; j--) {
  var swapped = false
  for(var i = 0; i <= j; i++) {
  if (ary[i] > ary[i + 1]) {
  swap(ary, i, i + 1)
  swapped = true
  }
  }
  if (!swapped) {
  break
  }
  }
  return ary
  }
- 数组的归并排序
  function mergeSort(ary) {
  if (ary.length < 2) {
  return ary
  }
  var mid = ary.length >> 1
  var left = ary.slice(0, mid)
  var right = ary.slice(mid)
  mergeSort(left)
  mergeSort(right)
  var i = 0
  var j = 0
  var k = 0
  while(i < left.length && j < right.length) {
  if (left[i] < right[j]) {
  ary[k++] = left[i++]
  } else {
  ary[k++] = right[j++]
  }
  }
  while (i < left.length) {
  ary[k++] = left[i++]
  }
  while (j < right.length) {
  ary[k++] = right[j++]
  }
  return ary
  }
- 数组的选择排序 每次遍历将最小值放到前面
  function swap(array, i, j) {
  let temp = array[i]
  array[i] = array[j]
  array[j] = temp
  }
  function selectSort(ary) {
  for (let i = 0; i < ary.length - 1; i++) {
  var minPos = i
  for (let j = i + 1; j < ary.length; j++) {
  if (ary[minPos] > ary[j]) {
  minPos = j
  }
  }
  swap(ary, i, minPos)
  }
  return ary
  }
- 数组的插入排序（将无序的部分插入到有序部分），利用排序二叉树，先将数组转化为排序二叉树，再 将二叉树遍历得到排序数组
  function insertIntoBST(root, val) {
  if (!root) {
  return new TreeNode(val)
  }
  if (root.val <= val) {
  root.right = insertIntoBST(root.right, val)
  } else {
  root.left = insertIntoBST(root.left, val)
  }
  return root
  }
  function bstSort(ary) {
  let root = ary.reduce(insertIntoBST, null)
  let i = 0
  inOrderTraverse(root, val => { ary[i++] = val })
  return ary
  }
- 数组的原地快速排序
  对应所有元素完全相同的数组，性能退化为 n*n , 调用栈深度为 n
  方法： 数组中随机取一个数 s 和最后一位交换位置；双指针从头开始遍历数组，快指针遇到比 s 小的就和慢指针交换位置，如此就可以遍历一遍后比 s 小的都在 s 左边，s 相当于排序了。然后递归操作
  function quickSort(ary, start = 0, end = ary.length - 1) {
  function swap(array, i, j) {
  if (i != j) {
  let t = array[i]
  array[i] = array[j]
  array[j] = t
  }
  return array
  }
  if (end - start <= 0) { return ary }
  let pivotIndex = start + Math.random() * (end - start + 1) | 0
  let pivotNumber = ary[pivotIndex]
  swap(ary, pivotIndex, end)
  let i = start, j = start
  for (; j < end; j++) {
  if (ary[j] < pivotNumber) {
  swap(ary, i, j)
  i++
  }
  }
  swap(ary, i, end)
  quickSort(ary, start, i - 1)
  quickSort(ary, i + 1, end)
  return ary
  }
- // 排序前后不改变相同元素的相对位置，则称为稳定的排序算法
  // 反之，则为不稳定的
  // 不稳定的排序算法：选择排序，就地快排
  // 稳定的排序算法：冒泡，归并，插入排序，bst 排序
- 数组的 sort 方法
  function qSort(ary, compare) {
  return quickSort(ary, compare)
  // 分治 divide and conquer
  function quickSort(ary, compare, start = 0, end = ary.length - 1) {
  if (end - start <= 0) {
  return ary
  }

  var pivotIndex = Math.floor(Math.random() \* (end - start + 1) + start)
  var pivot = ary[pivotIndex]

  swap(ary, pivotIndex, end)

  var i = start
  for(var j = start; j < end; j++) {
  if (compare(ary[j], pivot) < 0) {
  swap(ary, i, j)
  i++
  }
  }

  swap(ary, i, end)

  quickSort(ary, compare, start, i - 1)
  quickSort(ary, compare, i + 1, end)

  return ary
  }
  }

## 循环

- for 循环中 var 定义的变量是循环所在作用域变量，即作用域里面循环后面的代码可以引用 i 的值
  如果想变量只对 for 循环生效，用 let 定义 for 循环的变量，let 定义的变量属于严格模式，只在对应的区域块生效。
- for in 循环
  for(let 变量 in obj){} 将对象里面的属性名依次赋值给变量，每赋值一次循环一次
- for of 循环 遍历可迭代对象定义要迭代的数据。
  for...of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

## 链表结构

- 每个结点存储下一个点的位置的数据结构
  易增删，难查找，不连续占用内存
- 数组转化为链表
  - 方法 1
    - 首先遍历数组一次创造 n 个节点对象 node，value = Arr[i],next = null,node 全部 push 到数组 nodes 中
    - 接着再遍历数组 nodes 一次，将节点链接在一起，nodes[i].next=nodes[i+1]
  - 方法 2
    - 创建一个头部节点，使其 next 属性指向下标为 i 的节点，一次循环下去
      function arrTolist(arr) {
      let head = {
      value: undefined,
      next: null
      }
      let remmber = head
      for (let i = 0; i < arr.length; i++) {
      node = {
      value: arr[i],
      next: null
      }
      head.next = node
      head = node
      }
      return remmber.next
      }
  - 方法 3 递归
    - function arrayToList(arr){
      if(arr.length==0){
      return null
      }
      return {
      value:arr[0],
      next:arrayToList(arr.slice(1))
      }
      }
- 链表转化为数组

  - function listToArray(list){
    let result = []
    while(list != null){
    result.push(list.value)
    list = list.next
    }
    return result
    }

  - function listToArray2(list){
    if(list == null){
    return []
    }
    let tail = list.next
    return [list.value,...listToArray2(tail)]
    }

- 在某个节点前面插入一个值为 value 的新节点 (index 是下标号）
  function insert(list, index, value) {
  if (index < 0) {
  index = 0
  }
  下标小于 0 时就相当于 0
  if (!list) {
  return {
  value: value, next: null
  }
  }
  如果 list 是空节点，那就是在 null 前面加入一个新节点，index 只能为 0，返回其值
  if (index == 0) {
  return {
  value: value,
  next: list
  }
  }
  如果 index 为 0，即在 list 前面加一个节点
  var head = list 用 head 保存头节点
  var idx = -1 用 idx 记录下标

  while (idx != index - 1 && list.next) {
  idx++
  list = list.next
  }
  如果下标没有到达目标位置且 list.next 不为 null
  循环 idx 递增，list=list.next

  list.next = {
  value: value,
  next: list.next,
  }
  指针到达目标位置时，list.next 指向新节点，新节点又指向原来 list.next 的值
  return head
  }

- 链表的反转
  反转 head 后面的链表，再把反转的链表指向 head
  var reverseList = function (head) {
  if (!head || !head.next) { return head }
  let newHead = reverseList(head.next)
  head.next.next = head
  head.next = null
  return newHead
  };
- 链表的归并
  - 循环
    function mergeTwoLists(l1, l2) {
    let hummy = new ListNode()
    let hummy2 = hummy
    while (l1 && l2) {
    if (l1.val < l2.val) {
    hummy2.next = l1
    l1 = l1.next
    } else {
    hummy2.next = l2
    l2 = l2.next
    }
    hummy2 = hummy2.next
    }
    hummy2.next = l1 || l2
    return hummy.next
    }
  - 递归
    var mergeTwoLists = function (l1, l2) {
    if (!l1 || !l2) {
    return l1 || l2
    }
    if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2)
    return l1
    } else {
    l2.next = mergeTwoLists(l1, l2.next)
    return l2
    }
    }
- 链表的排序
  先递归二分再归并
  var sortList = function (head) {
  if (!head || !head.next) {
  return head
  }
  let hummy = new ListNode()
  hummy.next = head
  let slow = hummy
  let fast = hummy
  while (fast && fast.next) {
  slow = slow.next
  fast = fast.next.next
  }
  let left = head
  let right = slow.next
  slow.next = null
  left = sortList(left)
  right = sortList(right)
  function mergeTwoLists(l1, l2) {
  let hummy = new ListNode()
  let hummy2 = hummy
  while (l1 && l2) {
  if (l1.val < l2.val) {
  hummy2.next = l1
  l1 = l1.next
  } else {
  hummy2.next = l2
  l2 = l2.next
  }
  hummy2 = hummy2.next
  }
  hummy2.next = l1 || l2
  return hummy.next
  }
  return mergeTwoLists(left, right)
  };

## 哈希表

- 解决哈希表冲突
  - 扩容：数组中位置占用率超过某个值后数组扩容
  - 开放地址法：用两个数组，一个储存 key 一个储存映射值
  - 链表储存：数组储存链表，下标相同的 key 储存在同一个链表中，链表储存 key,value,next 3 个值
  - 多个哈希函数换着用：发生冲突换另外一个哈希函数
- 哈希表的查找效率 O(1) 将 keys 通过哈希函数转化为独一无二的数值储存在数组中，空间换时间。
- 哈希表的应用
  md5;sha1；对文件进行哈希映射
  垃圾邮件过滤，利用计算机中的位图结构
  位图：指一个由 0 和 1 组成的超大数组 [0,1,0,1,1,1,0......]

## 二叉树

- 完全二叉树在数组中表示
  对于下标为 i 的节点对于的左节点为 2i+1, 右节点为 2i+2
  对于下标为 n 的节点，其对应的父节点为 Math.floor((n-1)/2)

- 二叉树的排序插入
  var insertIntoBST = function (root, val) {
  if (!root) {
  return new TreeNode(val)
  }
  if (root.val > val) {
  root.left = insertIntoBST(root.left, val)
  } else {
  root.right = insertIntoBST(root.right, val)
  }
  return root
  };
- 利用二叉树对数组排序
  向将数组转化为排序二叉树（左边的节点一定比右边小），再中序遍历二叉树，将值储存在数组中就是排序的结果
  function bstSort(ary) {
  var root = ary.reduce(insertIntoBST, null)
  k = 0
  inOrderTraverse(root, val => {
  ary[k++] = val
  })

  return ary
  }

- 前中后序遍历
  前序遍历 根节点 左子数 右子数 看书看过的顺序
  function preOrderTraverse(root, action) {
  if (root) {
  action(root.val)
  preOrderTraverse(root.left, action)
  preOrderTraverse(root.right, action)
  }
  }
  中序遍历 左子数 根节点 右子数 看书看过一半的顺序 由左往右扫描
  function inOrderTraverse(root, action) {
  if (root) {
  inOrderTraverse(root.left, action)
  action(root.val)
  inOrderTraverse(root.right, action)
  }
  }
  后续遍历 左子数 右子数 根节点 看书看完的顺序
  function postOrderTraverse(root, action) {
  if (root) {
  postOrderTraverse(root.left, action)
  postOrderTraverse(root.right, action)
  action(root.val)
  }
  }

- 将数组转化为二叉树
  _方法一： 递归
  function arrayToTree(array, rootPos = 0) {
  if (array[rootPos] == null) {
  return null
  }
  return {
  val: array[rootPos],
  left: arrayToTree(array, rootPos _ 2 + 1),
  right: arrayToTree(array, rootPos * 2 + 2)
  }}
  *方法二 队列 创造一个储存数组，先进先出，使用 shift 和 push 方法达到效果
  function arrayToTree2(array) {
  if (array.length == 0) { return null }
  let root = new TreeNode(array[0])
  let nodes = [root]
  for (let i = 1; i < array.length; i++) {
  let current = nodes.shift()
  if (array[i] != null) {
  let node = new TreeNode(array[i])
  current.left = node
  nodes.push(node)
  } else {
  current.left = null
  }
  i++
  if (i == array.length) {
  break
  }
  if (array[i] != null) {
  let node = new TreeNode(array[i])
  current.right = node
  nodes.push(node)
  } else {
  current.right = null
  }
  }
  return root}

- 将二叉树转化为数组
  - 方法一 递归
    function treeToArray(root, pos = 0, result = []) {
    if (root) {
    result[pos] = root.val
    treeToArray(root.left, pos _ 2 + 1, result)
    treeToArray(root.right, pos _ 2 + 2, result)
    }
    return result}
  - 方法二 层次遍历 队列 队列里面没有值时循环结束
    function treeToArray2(root) {
    if (root==null ) { return [] }
    let result = []
    let nodes = [root]
    while (nodes.length) {
    let current = nodes.shift()
    if(current){
    result.push(current.val)
    nodes.push(current.left,current.right)
    }else{
    result.push(null)
    }
    }
    while(result[result.length - 1] === null) {
    result.pop()
    }
    return result}
  - 方法三 层次遍历
    function treeToArray3(root) {
    if (root) {
    var result = [root.val]
    var nodes = [root]
    while (nodes.length) {
    var curr = nodes.shift()
    if (curr.left) {
    result.push(curr.left.val)
    nodes.push(curr.left)
    } else {
    result.push(null)
    }
    if (curr.right) {
    result.push(curr.right.val)
    nodes.push(curr.right)
    } else {
    result.push(null)
    }
    }
    while(result[result.length - 1] === null) {
    result.pop()
    }
    return result
    }
    }

## 堆（Heap）

- 堆内存：对于大小无法确认的数据，计算机储存其内存地址，其本体储存在堆内存中
  栈内存（空间）：指储存正在等待调用返回函数的局部变量的一片的内存，其储存是连续的，大小是确定的
  调用栈：函数之间互相调用的逻辑关系
- 堆是一种数据结构，也叫优先队列（PriorityQueue），和堆空间没有任何关系
- 堆的结构
  - 堆是一个完全二叉树
  - 每个节点都比其子节点要大（小）
  - 根节点一定是最大（最小）值
- 对于堆，主要支持两种操作
- 往堆里面增加元素
- 从堆里面取出其最值
- 两种操作都要保证堆的结构
- 代码
  大堆
  class deap {
  constructor(nums) {
  this.elements = nums
  this.heapfy(nums)
  }
  add(val) {
  this.elements.push(val)
  this.heapUp(this.elements.length - 1)
  }

  heapUp(currIdx) {
  while (currIdx > 0) {
  let pIdx = (currIdx - 1) >> 1
  if (this.elements[pIdx] < this.elements[currIdx]) {
  this.swap(pIdx, currIdx)
  currIdx = pIdx
  } else {
  break
  }
  }
  }
  // 将某个节点的父节点调整为堆，且保持整个堆结构

  heapdown(currIdx, end = this.elements.length) {
  while (currIdx < end) {
  let maxIdx = currIdx
  let leftIdx = currIdx \* 2 + 1
  let rightIdx = leftIdx + 1
  if (leftIdx < end && this.elements[leftIdx] > this.elements[maxIdx]) {
  maxIdx = leftIdx
  }
  if (rightIdx < end && this.elements[rightIdx] > this.elements[maxIdx]) {
  maxIdx = rightIdx
  }
  if (this.elements[maxIdx] != this.elements[currIdx]) {
  this.swap(maxIdx, currIdx)
  currIdx = maxIdx
  } else {
  break
  }
  }
  }
  // 将某个节点调整为堆，且保持整个堆结构
  heapfy() {
  let curr = (this.elements.length - 2) >> 1
  for (let i = curr; i >= 0; i--) {
  this.heapdown(i)
  }
  }
  // 从不是叶子节点开始进行倒序 headdown 操作，得到了整个堆结构数组

  swap(i, j) {
  let temp = this.elements[i]
  this.elements[i] = this.elements[j]
  this.elements[j] = temp
  }

  SortArray(arr){
  this.heapify(ary)
  for(var i = ary.length - 1; i > 0; i--) {
  this.swap(ary, i, 0)
  this.heapdown(0)
  }
  return ary
  }

  push(val){
  this.elements.push(val)
  this.heapUp(this.elements.length - 1)
  }
  // 在末尾添加元素

  pop(){
  var result = this.elements[0]
  var last = this.elements.pop()
  if (this.elements.length == 0) {
  return result
  }
  this.elements[0] = last
  this.heapdown(0)
  return result
  }
  // 取出堆顶

## 回溯算法

- 有条件的穷举，当有条结果满足结束条件时将其记录下来
- depth first search 尝试所有可能，符合条件走下一步，不符合条件回到上一步，直到所有符合条件的路径都尝试
- 回溯条件：判断是否进行下一步的条件
- 结束深度搜索条件：深度搜索结束，将一种可能结果记录下来
- 删除路径：找到满足条件的路径后删除最后一步寻找更多的可能
- // leetcod 77 78 17 22
  // 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合
  var combine = function (n, k) {
  let res = []
  if (n < k) {
  return res
  }
  function backtrack(result, n, k) {
  if (result.length === k) {
  res.push(result.slice())
  return // 结束条件，返回上一层
  }
  for (let i = n; i > 0; i--) {
  result.push(i)
  backtrack(result, i - 1, k) 深度搜索
  result.pop() 找到满足条件的路径后删除最后一步寻找更多的可能
  }
  }
  backtrack([], n, k)
  return res
  }

## 算法技巧

- 进制转换
  var n = 3123
  while(n > 0){
  var digit = n % 2
  console.log(digit)
  n = (n - digit)/2
  }
- 判断素数的简化方法
  - 遍历到根号 n 即可
  - 前面再加一些判断缩小范围，比如能不能被 2,3,5，7 等整除
    var isPrime = function(n) {
    if (n < 2) {
    return false
    }
    var sqrt_n = Math.floor(Math.sqrt(n))
    for(var i = 2; i <= sqrt_n; i++) {
    if (n % i == 0) {
    return false
    }
    }
    return true
    }
  - 利用正则表达式判断
    function isPrime(n) {
    return !/^(?=(.{2,})\1+\$)/.test('x'.repeat(n))
    }
  * 素数两性定理
    把素数分为 6 列，素数全部存在于第 1 列和第 5 列（2 和 3 除外）；第 2，4 列全部能被 2 整除。第 3，6 列全部能被 3 整除
  * 算法中递归优雅易懂，但是耗时；超时可以转化为循环语句
  * 记录递归深度的技巧
    depth = 0
    var levelOrder = function(root) {
    depth++
    if (root) {
    if (depth in result) {
    result[depth].push(root.val)
    } else {
    result[depth] = [root.val]
    }
    levelOrder(root.left)
    levelOrder(root.right)
    }
    depth--
    }
- 递归下降，解析语法数
  leetcode 1106. 解析布尔表达式
  var parseBoolExpr = function(expr) {
  var i = 0
  return parse()
  function parse() {
  if (expr[i] == 't') {
  i++
  return true
  }
  if (expr[i] == 'f') {
  i++
  return false
  }
  if (expr[i] == '!') {
  return parseNot()
  }
  if (expr[i] == '&') {
  return parseAnd()
  }
  if (expr[i] == '|') {
  return parseOr()
  }
  }

  function parseNot() {
  i += 2
  var value = parse()
  i++
  return !value
  }

  function parseAnd() {
  i += 2
  var result = true
  while (true) {
  var value = parse()
  result = result & value
  if (expr[i] == ')') {
  i++
  break
  }
  if (expr[i] == ',') {
  i++
  }
  }
  return result
  }

  function parseOr() {
  i += 2
  var result = false
  while (true) {
  var value = parse()
  result = result || value
  if (expr[i] == ')') {
  i++
  break
  }
  if (expr[i] == ',') {
  i++
  }
  }
  return result
  }
  }

## ES6 相关知识

- https://leanpub.com/understandinges6/read#leanpub-auto-default-values-in-modules
- ES6 标准里形参的声明都是默认为用 let 声明
- 剩余参数（参数 1， ... 剩余参数）只能写在最后
  function addEntry(squirrel, ...events) {
  return {
  squirrel: squirrel,
  events: events,
  }
  }
- 参数的默认值 （属性 = 默认值）
  function slice(array,start = 0,end = array.length){}
- 展开运算符 (... 将数组两边的【号和】号中合掉） 不能单独使用，作为参数使用
  Math.max(...[1,2,3]) == Math.max(1,2,3) =>3
- class 语法 ，也就是构造语法糖
  将一类功能对象封装；class 类名{}

  - 这样写的好处

  * 里面的方法默认是不可枚举的
  * 不使用 new 会报错
  * 方便继承

  - constructor() {} 构造函数
    static 用来定义一个类的一个静态方法。调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法；方法放在类上而不是实例 this, 减少原型链压力
    各种方法直接写在{}里面
    里面不要加，号和；号
  - class B extends A B 类继承 A 类
    B.prototype._proto_ === A.prototype
    B._proto_ === A
    B 类可以直接用 A 的方法，注意不要命名和父类的同名方法，会覆盖父类方法，原型污染
    super() 调用父类构造函数，先构造一个父类的实例，然后将 this 绑定到这个实例上，所以 super() 调用之前不能使用 this
    继承时在构造函数中需要调用 super，super 相当于父类的构造函数，后面也可以直接接父类的方法 super.method
    B 类如果不写构造函数也行，会默认写
    constructor(...arg) {
    super(...arg)
    }

- class A {
  static a(){}
  static b(){}
  constructor(){}
  method1(){}
  method2(){}
  get length(){}
  set length(val){}
  }

- class Queue {
  static from(ary) {
  var q = new Queue()
  for (var val of ary) {
  q.add(val)
  }
  return q
  }

      constructor(initVals) {
          this._head = null
          this._tail = null
        
          for (var val of initVals) {
              this.add(val)
          }
      }
        
      add(val) {
          var node = {
              val: val,
              next: null,
          }
          if (this._head == null) {
              this._head = this._tail = node
          } else {
              this._tail.next = node
              this._tail = node
          }
          this._size++
          return this
      }
        
      remove() {
          if (!this._head) {
              return undefined
          }
          this._size--
          var node = this._head
          this._head = this._head.next
          if (this._head == null) {
              this._tail = null
          }
          return node.val
      }
        
      get size() {
          return this._size
      }

  }

- 解构语法
  [a,b]=[b,a] a 和 b 互换位置
  {a，b} = {a:1,b:2} 拿到 a 和 b
- 模板字符串 ``
  - 用反引号（``）来表示，模板字符串可以包含特定语法（\${expression}）的占位符；
    `${354}a${6}sfdf${12}safs${5+2}daf${2*1}dsaf` => "354a6sfdf12safs7daf2dsaf"
  - 模板字符串开头如果有一个函数表达式，该函数称为模板字符串的标签函数，它会在模板字符串处理后被调用
    fun `${354}a${6}sfd\f${12}\sa${5+2}da${2*1}df`
  - 标签函数 fun 的 arguement 为
    第一个元素为一个数组，里面是由占位符分割的字符串组成的，再加上 raw 属性，占位符
    [["","a","sfdf","sa","da","df",row:["","a","sfd\f","\sa","da","df"]],
    "354","6","12","7","2"
    ]
  - 在标签函数的第一个参数中，存在一个特殊的属性 raw ，我们可以通过它来访问模板字符串的原始字符串，而不经过特殊字符的替换。
- 伪调用 可以优化调用栈，防止爆栈
  function(){
  var a = 1
  return g(a)
  }
- 模块的导入导出
  - 模块的导出
    - export var color = "red";
    - export function sum(num1, num2) {
      return num1 + num1;
      }
    - export class Rectangle {
      constructor(length, width) {
      this.length = length;
      this.width = width;
      }
      }
  - 模块的导出 import { identifier1, identifier2 } from "./example.js";
    import {color，sum,Rectangle} form path
  - 模块的导入和导出都需要写在最外层作用域，不能嵌套到其它作用域，方便静态分析
  - 可以设置一个默认的导出，当导入一个没有的模块名时就导入这个默认的
    export default function(num1, num2) {
    return num1 + num2;
    }
  - 要引入到 type 为 module 的 script 标签里<script type = 'module'>
- 私有属性的实现
  如果一个对象还有指针指向，它就不会被垃圾回收
  弱引用，如果一个对象仅仅被 weakMap/WeakSet 内部指向时，它可以被垃圾回收
  var C = (function(){
  var classProperties = new WeakMap()
  return class A {
  constructor(name, age) {
  var \_this = {}
  \_this.age = age
  \_this.name = name

        classProperties.set(this, _this)
      }
      getName() {
        var _this = classProperties.get(this)
        return _this.name
      }

  }
  }())
  var c = new C()
  c = null

- Proxy 代理
  对对象属性的读取设置(get,set)，方法调用等等的拦截

## 高阶函数

- forEach 函数

  - 源代码
  function forEach(array,action){
  for(let i = 0;i< array.length;i++){
  action(array[i], i, array)
  }}
  array.forEach(function(){}) 方法从头至尾遍历数组，为每个元素调用指定的函数。
  action 最多可以传递 3 个有效的参数 (arr[i]，索引，数组），修改原数组只能通过第二个和第三个参数修改
  forEach 只有一个参数时，即每个元素的处理函数。
  <!--  var numbers = [1, 2, 3];
   numbers.forEach(x => console.log(x));
   // 同等于
   numbers.forEach(function (x) {
       console.log(x); -->

- filter 函数 返回新数组

  - 源代码
  function filter(array, test) {
  let result = []
  for (let i = 0; i < array.length; i++) {
  if (test(array[i], i, array)) {
  result.push(array[i])
  }}
  return result}
  array.filter(function(){}) filter 函数的作用是遍历该集合，然后将该集合中符合某些特定条件的元素组成新的数组，并返回该新数组。
  test 最多可以传递 3 个有效的参数 (arr[i]，索引，数组）
  filter 只有一个参数时，即判断所有元素是否符合条件的处理函数。
  <!--  var digits = [1, 4, 5, 10, 15]
  var even = digits.filter(function (number) { return number % 2 == 0 })
  console.log(even))
  // [4, 10] -->

- map 函数 返回新数组 \*源代码
function map(array, mapper) {
let result = []
for (let i = 0; i < array.length; i++) {
result.push(mapper(array[i], i, array))
}
return result}
array.map(function(){}) 对数组的每个元素调用定义的回调函数并返回包含结果的数组
mapper 最多可以传递 3 个有效的参数 (arr[i]，索引，数组）
map 只有一个参数时，及给出映射关系的处理函数
  <!-- var array = [16,25,36];
  array.map(Math.sqrt);
  //array = [4,5,6]

  var array = [11, 22, 33, 44, 55];
  console.log(array.map(function (n) { return n % 10 }))
  //array = [1,2,3,4,5] -->


    * reduce 函数 返回最终运算的结果
      * reduce 源函数
          function reduce(arr, reducer,initalVal=arr[0] ) {
            var  i = 0
            if (argument.length===2){
              i=1
            }
            for (; i < arr.length; i++){
                initalVal = reducer(initalVal,arr[i]，index,arr)
            }
            return initalVal
          }
      * reduce 可以接受 3 个参数，数组（作为数组的方法时可以省去），reducer 函数，初始值（不设置时默认为数组第一项）； reducer 是必要参数，其它可选
      * 执行函数 reducer 接受 4 个参数，initalVal（上一次执行结果，第一次为初始值）arr[i] 数组的第 i 项，数组下标，数组本身（作为数组的方法时可以省去）；initalVal 和 arr[i] 是必要参数，其它可选
    
      Array 的 reduce() 把一个函数作用在这个 Array 的 [x1, x2, x3...] 上，这个函数必须接收两个参数，reduce() 把结果继续和序列的下一个元素做累积计算，其效果就是：
      [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
     <!--  var arr = [1, 3, 5, 7, 9];
      arr.reduce(function (x, y) {
      return x + y;
      }); // 25 -->
    
    * sort 函数
      用于数组的排序，返回值大于 0 交换位置，其它位置不变
      array.sort(function(a,b){return a - b})  从小到大排序
      array.sort(function(a,b){return b - a})  从大到小排序
    
    * bind: 绑定 this 和参数 ，参数传多了只接受前面的参数，后面的参数无效；且 this 只能绑定一次，多次绑定不生效
      apply: 设定 this 和参数，参数以数组形式传入
      call: 设定 this 和参数，参数不能以数组的形式传入
      如果只绑定参数而不指定 this, 通常将 this 设置为 null，新的绑定函数不使用 this 即可
    
    function myBind(thisArg, ...fixedArgs){ <!-- thisArg 是 this 要绑定参数，fixedArgs 是其它的参数 -->
      let self = this <!-- 谁调用了这个函数谁就是 this -->
      return function bound(...arguments){
        fixedArgs.push(...arguments)<!-- 合并其它参数 -->
        if(new.target=== bound){
          return new self(...fixedArgs)
    
        <!-- 如果是构造函数调用了 mybind 函数，提供的 this 就会被忽略，thisArg 会被忽略掉；其它的参数会参与绑定，并且返回一个新的构造函数 -->
    
        }else{
        return self.apply(thisArg,fixedArgs)
        }
      }
    }

## 对象原型

- 基本关系
  几乎任何对象有原型的‘原型’指用来查找属性的 fallback 对象：obj.**proto**/Object.getPrototypeOf(obj)，称为“原型”
  每个函数（且一般只有函数才有）都有一个原型属性指的是 F.prototype（我的实例的原型），称为“原型属性”

  函数的原型是函数的构造函数的原型属性
  Function.**proto** ===Function.prototype
  String.**proto** ===Function.prototype
  Number.**proto** ===Function.prototype
  Object.**proto** ===Function.prototype

- 构造函数 var f = new Function()

  - new 运算符会进行如下的操作：
    创建一个空的对象 A{}，A 的原型是构造函数 F 的原型属性
    将 this 绑定到新创建的对象 A，并且用指定的参数调用构造函数修改该对象。
    如果该函数没有返回值，则返回 this
    如果该函数有返回值但是返回的不是对象时，还是返回 this
    如果该函数返回的是对象时，返回该对象
  - new.target === 构造函数
    new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。
  - new 的优先级比较高，比。号高
  - new 后面接一个函数时，如果函数没有参数直接调用，（）可以省去

- 原型

  - 每个函数的原型属性默认指向空的对象{}，该空对象的原型是 Object.prototype
    f.prototype -> {} -> Object.prototype -> null

  - constructor 属性 ，该属性指向了用于构造此实例对象的构造函数。
    Foo.prototype.constructor === Foo
    f1.**proto**.constructor === Foo

  - 判断一个值的原型是谁就看其本身是什么类型，然后找到其类型的构造函数的原型属性
    Object.getPrototypeOf([1]) === Array.prototype
    Object.getPrototypeOf({"a":2}) === Object.prototype
  - null ,undefined 没有原型
  - Object.prototype 的原型是 null, 一般也认为其也没有原型

  - JS 原生的几个构造函数的原型属性是其第一个实例，历史遗留问题
    Object.prototype.toString.call(String.prototype)==="[object String]"
    Object.prototype.toString.call(Function.prototype) === "[object Function]"

- 可以通过 Object.prototype.toString.call（类型）判断数据类型，会返回"[object 数据类型】"
  （这种判断方式只能判断原生类型，自己写的构造函数创建的实例都会返回"[object Object]")
  Object.prototype.toString.call([]) ==="[object Array]"
  Object.prototype.toString.call(null) === "[object Null]"
  Object.prototype.toString.call(undefined)==="[object Undefined]"
- instanceof 判断一个对象是不是构造函数的实例 person instanceof Person
  可以在原型中寻找判断
- typeof 用来判断原始数据类型
  Object.prototype.toString.call 用来判断内置对象类型
  instanceof 用来判断自定义对象类型（构造函数）

- this

  - 当一个函数以方法的形式被调用时，如 array.length，函数的 this 就是调用它的对象
  - 以纯函数形式调用时，this 就是 window f()
  - 但用 new 来调用 this 时，this 就是那个新建的对象； 如构造函数；
  - this 永远不能被赋值，即 this 不能写在等号左边
  - this 永远指向一个对象，如果指向了一个原始数据类型会将原始数据类型包装成对象
  - 箭头函数不会创建自己的 this, 它只会继承自己的作用域链的上一层作用域的 this 对象

- this 的丢失问题
  this 指向调用的对象与函数声明的位置无关，只与调用位置有关，如果在调用位置还使用声明位置的 this，this 会丢失；解决方法通过 bind 绑定 this 或者通过箭头函数，箭头函数的 this，总是指向定义时所在的对象，而不是运行时所在的对象。

- 不能通过操作对象来改变对象的原型的属性，可以直接操作对象的原型
  obj.**proto**. 属性名 = 属性值

- Object.getPrototypeOf(obj) == obj.**proto**
  Object.prototype 所有原型对象的根，其没有原型
  Function.prototype 所有函数原型的根
  Array.prototype 所有数组原型的根
  Function.prototype 的原型是 Object.prototype , 函数不是 Object 的属性，函数原型属性的原型指向 Object 的原型属性
  Array.prototype 的原型是 Object.prototype，数组不是 Object 的属性，数组原型属性的原型指向 Object 的原型属性

- Object.create（新创建对象的原型对象） 即为新创建的对象指定一个原型对象
  person2 = Object.create(person1) 为 person2 设置原型 person1
  Object.getPrototypeOf(person2,person1) 为 person2 设置原型 person1

- js 中有可枚举属性和不可枚举属性的区分，不可枚举属性不可以通过 for/in 循环访问
  in 运算符判断对象及其原型中是否有对应的可枚举属性，for/in 循环也可以访问到原型中的可枚举属性
  hasOwnProperty() 方法只访问自身的属性，不访问原型； map. hasOwnProperty("toString")
- Object.defineProperty() 为对象添加有特殊性质的属性；定义是否可被枚举属性，可被写，可被重新设置等等；
  Object.defineProperty(obj ,"asd" ,{ get: function(){return this.a\*this.b} , set: function(val){console.log(val)}})

- get 和 set 方法

  - 在对象中指定属性的读取函数和修改函数，属性在读取和修改时会分别调用 get 和 set
  - 使用方法 obj = {a:1 ,b:2, get asd(){return this.a\*this.b},set asds(val){console.log(val)} set 不能有返回值
  - 调用方法 obj.asd，get 有返回值 ； obj.asds=123123 set 一定要赋值
  - 都可以通过 Object.defineProperty() 添加到对象中
    Object.defineProperty(obj ,"asd" ,{ get: function(){return this.a\*this.b} , set: function(val){console.log(val)}})

- 面向对象的含义

  - 封装：把表达一个事物的信息及对其可能进行的操作（即函数）放在一起。
    放在一起最终形成
    // class 描述一类事物
    // object 描述某一类物事的具体个体

    同一类对象都有相同的一组属性和一组函数

  - 继承：让一个类直接获取另一类的所有属性和方法（重用已经写好的代码）

  - 多态：不关心得到的事物具体是什么类别，更这个事物是否有某方面的特性（有特定的一组属性和方法）
    例如对象，数组等都有 toString 方法，我们可以不关心调用这个方法的类型和调用结果，大家都可以用 toString 这个接口调用到自己想要的结果

## 正则表达式 (Reg)

- 目的：作字符串的模式匹配
- 一种领域特定语言（DSL/Domain specific language）, 可以在多种语言和工具中使用，是一种对象
- 创建方法
  - var reg1 = new RegExp("abc"，"ig") 构造函数
  - var reg2 = /abc/ig 直接量 / 字面量
  - re1 = /foo\nbar/ 字符串的语法（\n;\t）在正则表达式字面量里面不生效 /foo\nbar/
    re2 = new RegExp("foo\\nbar") 构造函数里面有回车功能，所以需要加、转义 /foo\nbar/
  - 如果正则表达式里面有自己的特殊符号语法时（如 + \* ？等等），需要转义
- new RegRxp("") => /(?:)/ 特例，不匹配任何内容
  /(?:)/.exec("asd") =>["", index: 0, input: "asd", groups: undefined]

- 相关方法

  - test /ab\d/.test("ab5sd")=>true 判断正则表达式和字符串是否匹配
  - exec /\d+/.exec("one two 100")=> ["100", index: 8, input: "one two 100", groups: undefined] 无法匹配返回 null，否则返回一个表达字符串信息的对象

- 相关属性

  - source 表示正则表达式的源代码 /asdf/.source=>"asdf"
  - lastIndex 表示正则表达式下一次匹配的起始位置，默认为 0，只有启用了全局 g 才可以使用；
    匹配成功后把 lastIndex 的值变为匹配位置（index）的后一个位置，下一次匹配从 lastIndex 位置开始；匹配失败变为 0；
    由于 lastIndex 的该特性，在全局模式下 text,exec,replace 方法的匹配位置都会受到影响，要小心使用
  - dotAll 表示。号是否代表所有的符号
  - ignoreCase 忽略大小写，缩写为 i
  - sticky 要求每一次匹配必须从上一次匹配结束之后的位置（lastIndex）开始匹配（缩写为 y ）
  - multiline 表示可换行，缩写为 m
  - unicode 表示通过 16 进制 unicode 编码匹配，缩写 u
  - flags: 表示 i,g，m,y.u 等这些属性集合

- 匹配字符集 []
  \d : [0-9] \D：前者取反
  \w:[0=9a-zA-Z\_] 数字字母加上一个下划线 \W：前者取反
  \s : 任意空白的字符 \S: 前者取反
  . : 除了换行符以外的任意符号
  [^] : 可以取 ��� 所有的符号，包括换行符；^ 在这里是取反的意思

  - [] 里面的特殊字符都没有特殊含义，仅仅代表一个普通字符 [+ \* . ? 等等】
  - [] 开头可以加一个脱字符 ^ /[^01]/ 表示非 0 和非 1 ； /^01/ 表示字符串的起始位置为 0；

- 相关规则
- 重复
  只对前面紧挨着的一个字符或者一个组生效
  - "+"号，出现多次
  - "\*" 号 出现任意次数
  - "?" 出现 0 次或者 1 次
  - {n} 出现 n 次 {2,4} 2 到 4 次 ； {4,}4 次及以上


    * 贪婪匹配
      由于正则表达式的回溯机制，每个正则符号都会首先尝试匹配最多的内容然后再回头，这种模式就是贪婪匹配
    * 非贪婪匹配
      和贪婪匹配相反，每个正则符号尽可能匹配少的内容，只有在剩余部分没办法完成匹配时才会匹配更多的内容
      表示方法： 在重复操作符后面加上？即变为非贪婪匹配（+?;*?;??;{}?;）
    * 匹配 unicode 码对应的字符（开启 16 进制 unicode 模式配合、u 使用）
       /\u{6211}/u.test("我")=>true
       /[\u{6211}-\u{7411}]/u.test("是")=>true

- 分组

  - 使用（）号，里面的内容会当作一个整体，（）里面匹配到内容单独添加到相关方法的返回值里的行为叫做捕获，也叫捕获分组

  - 非捕获分组：在（）内部前面加上？： 即变为 (?:), 非捕获分组的内容会当作一个整体，但是（）里面匹配到的内容不会添加到相关方法的返回值里

  - 为分组取名：(?<name>) 在括号前面加上一个？号和尖括号，名字写在尖括号里面，命名的分组信息会出现在返回值的 group 属性里面；（在旧的浏览器无法使用）
    /(?<year>\w\d)/.exec("adasd2313")=>["d2", "d2", index: 4, input: "adasd2313", groups: {…}]
    /(?<year>\w\d)/.exec("adasd2313").groups =>{year: "d2"}

  - 分组的后向引用
    "韩朵朵 李依依".match(/.(.)\1/g)=>["韩朵朵", "李依依"]
    "ABBA ABBB".match(/(.)(.)\2\1/g)=>["ABBA"]
    正则表达式里面的、n 代表的是对第 n 个分组的重复引用 （1<=n<=9）

- 匹配

  - 使用分组匹配到的内容也会出现到数组中
    /foo(bar)(bas)baz/.exec("foobarbasbazaaa")=>["foobarbasbaz", "bar", "bas", index: 0,input: "foobarbasbazaaa", groups: undefined]
  - 如果分组没有匹配到字符串，在数组对应的元素是 undefined
    /foo(bar\d)?baz/.exec("foobaz")=> ["foobaz", undefined, index: 0, input: "foobaz", groups: undefined]
  - 如果分组匹配到了多个元素，那么数组中只有最后一个匹配项
    /foo(bar\d)+baz/.exec("foobar1bar2bar3baz")=>["foobar1bar2bar3baz", "bar3", index: 0, input: "foobar1bar2bar3baz", groups: undefined]

- 零宽断言
  零宽断言：匹配两个符号之间的一个位置而不是一个符号（宽度为零）
  匹配发生时，光标不会移动，所以可以对同一个位置执行多个零宽断言匹配，只有当每个断言都成功时才可以
  有 4 种零断言：
  (?=expr) 正预测零宽断言，这个位置的右边满足 expr /er(?=ads)/.exec("aqqweradssd")=>["er", index: 4, input: "aqqweradssd", groups: undefined](?!expr) 负预测零宽断言，这个位置的右边不满足 expr /(?!f..)aa/.exec("aafafffffax")=>["aa", index: 0, input: "aafafffffax", groups: undefined](?<=expr) 正回顾零宽断言，这个位置的左边满足 expr（旧版 JS 不支持）
  (?<!expr) 负回顾零宽断言，这个位置的左边不满足 expr（旧版 JS 不支持）


    *单词和字符串边界
      ^ === /(?<![^])/  字符串的开头  左边不出现任何字符
      $ === /(?![^])/   字符串的结尾   右边不出现任何字符
      \b === /(?<=\w)(?=\W)|(?<=\W)(?=\w)|(?<![^])|(?![^])/   左边是字符右边不是 或者 左边不是字符右边是 或者 字符串开头 或者  字符串结尾
       单词边界是字符串的开始或者结束位置，也可以是任意单词（/w）和任意非单词字符（/W）之间的位置
      下面。号左右两边都是单词边界，因为"."是、W, 而其左右两边都是、w, 他们中间就是单词边界
      "bar.baz".match(/\b\.\b/)=>[".", index: 3, input: "bar.baz", groups: undefined]
    
    * 字符串和正则表达式相关的方法
      -match, 不考虑正则表达式的 lastIndex 属性。
        当正则表达式有 g 标志的时候，匹配出所有能够满足整条正则表达式的内容，不会把分组捕获到的内容也放入结果数组
        当没 g 标志的时候，匹配出第一条能满足的内容，同时把分组捕获到的内容也放入结果数组
    
      - replace(RegExp|String, String|Function)
        两个参数都是字符串：匹配第一次出现的内容为目标内容，不会修改原字符串
        首参为正则
        次参为字符串，里面的 $&,$1,$2~$9 是特殊内容，表示匹配到匹配到的内容以及各个分组捕获到的内容
        次参为函数，把整个匹配到的内容以及各分组捕获到的内容传给函数做为参数，把函数返回值插入被替换位置，有多少次匹配，函数就会调用多少次
    
      -re.exec(str) 方法
        如果 re 不带 g 标志，则完全等同于 str.match(re)
        如果 re 带有 g 标志，则从 str 的 re.lastIndex 位置开始查找，查找成功后把 re.lastIndex 置为匹配位置的后一个位置
        查找不成功的时候，返回 null，把 lastIndex 置为 0
    
      -str.split(String|RegExp)
        当参数是字符串时，按字符串把原字符串拆成数组
        当参数为正则时，按正则把原字符串拆成各部分的数组，但是
        当正则里有捕获分组时，分组捕获到的内容也会出现在结果数组的相应位置
    
     * https://regex101.com/    debug 正则表达式网站
       https://regexper.com/    查看正则表达式流程图

## Date

- i18n internationalization 国际化
  i10n localization 本地化
- JS 中月份从 0 开始，日期是从 1 开始（坑）
- 时间戳 1970 年距离现在多少毫秒；1970 前的时间用负数表示 d.getTime() 获取到现在的毫秒时间
- Date.now() 当前时间戳
- moment.js https://momentjs.com/
  最常用的日期库

## DOM Document Object Model

## 事件

     *elements.click()  触发 click 事件，可以触发除默认交互之外的交互行为
     * elements.dblclick()  触发双击事件前会触发两次单击事件
     *Event.which 表示哪一个鼠标按钮被按下，
      0 表示无，1 表示左键，2 表示中键，3 表示右键；
      无法表示组合鼠标键，此属性总是只展示最先按下去的键
     *Event.buttons 表示哪些鼠标按钮被按下，
      它的二进制形式的最低位表示左键 (001)，第二位表示右键 (010)，第三位表示中键 (100)
      所以同时按下中键和右键将会得到 6，依此类推 (100 | 010 = 110)

- 滚动事件（scroll)
  Element.scrollHeight: 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容
  Element.scrollTop 属性可以获取或设置一个元素的顶部到视口可见内容（的顶部）的距离；当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为 0。
  Window.scrollTo 滚动到文档中的某个坐标。
  Element.scrollBy(x,y) 设置元素里面的滚动水平垂直移动的 px
  滚动事件"scroll"的 preventDefault 无法阻止滚动，因为该事件处理器是在滚动之后才触发的， mouseWheel/DOMMouseScroll 这两个也是滚动事件，可以设置 passive: false 阻止滚动
  window.addEventListener('mousewheel/touchmove', f, {
  passive: true// 告诉浏览器将不会在事件处理函数中调用 preventDefault，浏览器可以事件处理函数运行的同时，就开始执行默认事件（最典型的情况即为滚动页面），使滚动更流畅（浏览器少数可以边解析边渲染的地方）
  })
- 长度相关
  - element.offsetWidth/element.offsetHeight 元素空间大小 包含边框
  - element.clientWidth/element.clientHeight 元素空间大小 不包含边框
  - element.getBoundingClientRect 返回一个对象，表示元素 4 个方位到视口左上角垂直距离
  - element.getClientRect 用于分行的元素，每行都有一个结果，返回数组
  - innerHeight 窗口高度
  - document.body.scrollHeight 整个页面高度
  - pageYOffset/scrollY 当前滚动位置
  - Event.clientX/clientY 鼠标相对于视口的位置
  - Event.pageX/pageY 鼠标相对于文档的位置
- 焦点事件
  - focus/blur 不会冒泡
    focusin/focusout 会冒泡
    window.onfocus/blur 窗口也有焦点事件
    elements.foucs() 使元素获得焦点
- 加载事件
  - window.onload 是在页面所有资源加载完成时触发，包括 css, 图片，脚本等等；常用于页面构建完成时使用 load 进行初始化
  - 浏览器遇到<script>标签会立即执行，之后再执行下面的代码；因为 js 代码里面可能会有 DOM 操作，这样不同的执行时刻页面有不同的显示，所以浏览器都是立即执行
    所以大型网站一般都把<script>标签放到后面；
    <script async src =""> <script defer src = "">为有 src 属性的 script 加上 async 或者 defer 属性会使 script 在页面加载完成之后执行
    CSS 代码写在前面，这样遇到标签就可以渲染其样式
  - load 事件是在所有外部资源加载完成时触发，而 DOMContentLoaded 是在 DOM 解析完就触发，所以我们现在都用更快的 DOMContentLoaded
    beforeunload 事件，关闭页面或者跳转链接时触发
  - readystatechange 事件 当文档的 readyState 属性发生改变，readystatechange 事件会被触发。
    document.readyState === "complete" 表示 DOM 解析完，可以替代 DOMContentLoaded。兼容性更好
  - 脚本执行时间线
    - 很多事件都会触发脚本（程序）执行，同一文档中无法同时执行 2 个脚本（CSS3 动画除外，其可以继续持续执行）
    - js 是单线程语言，但可以使用 Worker 函数将耗时的操作放到后台运行，其可以独立文档主程序运行；
      worker 之间不能共享数据，只能通过事件"message"与 postMessage 来发送消息，所发送的消息是复制之后发送过去的，所有修改接收到的消息是不会改变源消息的；
      worker 内不能访问 dom, 以及任何与 UI 相关的接口
  - 时间定时器
    - setTimeout 设置函数多少毫秒后调用 其返回值是一个任务号数字
      clearTimeout（number） 清除该任务，不在调用队列里
      var number = setTimeout(fun,time)
    - setTimeout 最快也要将其调用栈里面的代码执行完毕之后再调用函数，即使时间设置为 0；
    - setInterval/clearInterval 设置函数每隔多少毫秒调用
  - 事件防抖（降低事件多次连续迅速触发，如 mousemove，scroll)
    - debounce 防抖函数
      function debounce(f,time){
      let timeId = null
      return function(...argments){
      clearTimeout(timeId)
      var timeId=setTimeout(f(argments),time)
      }
      }
      只有在连续时间内，不在触发频繁事件后的 time 秒后，执行真正的回调，如输入联想
    - throttle 节流函数
      function throttle(f, duration) {
      var timerId
      var lastRunTime = 0
      return function(...args) {
      clearTimeout(timerId)
      var now = Date.now()
      if (now - lastRunTime > duration) {
      f(...args)
      lastRunTime = now
      } else {
      timerId = setTimeout(() => {
      f(...args)
      lastRunTime = Date.now()
      }, duration)
      }
      }
      }
      以一定的频率触发，降频；如鼠标滚动
      理解上述函数注意 setTimeout 里面的函数调用时修改局部变量影响其他事件是否触发


    * 创建自定义事件
      Events 可以使用 Event 构造函数创建如下
      var event = new Event('build');
      elem.addEventListener('build', function (e) { ... }, false);
      elem.dispatchEvent(event)  （触发改事件）

## swiper

- 轮播图库
  https://idangero.us/swiper/demos/

## base64

- 64 进制编码
  0 —— 9 10
  a —— Z 52
  - / 2
- 早期电子邮件附件的编码传递
- data uri 将数据 64 位编码
- 全字母解码 （atob）
  全字母编码 （btoa）
  \*DataURL 把数据直接编码进了 url 里面。可以通过 base64，也可以直接把数据的原始文本直接放进 url 中

# 计算机网络

## 计算机网络的基础知识

- ip 地址的分类
  \*IP 地址是按照地区划分
  - A 类地址第 1 字节为网络号，其它 3 个字节为主机号。 A 类地址的网络号第一位固定为 0，网络号只有 7 位可以使用，可以指派的网络号是 2^7-2 = 126 个。
    B 类地址的前两个字节为网络号，后两个字节为主机号。
    C 类地址的前三个字节为网络号，最后一个字节为主机号
- 带宽：单位时间内通过网络的数据量
  延迟：传播需要的时间
- 常用协议端口号
  http:80
  DHCP:67
  DNS: 53
  FTP：21
  NTP: 123 Network Time Protocol 网络时间协议，用于时间同步，基于 UDP 协议
- 域名：域名就是为 IP 地址起的名字；IP 地址不好记，可以用域名代表 IP 地址
- VPN Virtual Private Network
  - VPN 相当于给每个内部设备配置了一个虚拟网卡，用与内部设备的通信
  - 每个内部设备可以连接总部的 VPN 服务器，通过服务器获取接收数据
  - 加密性高
- IPv6
  - 128bite 长度，是 ipv4 的 4 倍，可以有 2\*\*128 个 ip 地址
    升级推广难，少数几构使用，目前用 NAT 路由器这种方式
    现在的推广的方式是在 IPv6 地址传播过程中把其包裹在 ipv4 的数据里，只在起始和结束位置将 ipv6 解析出来
- 基于 UDP 的协议：dhcp/dns/ntp 低延迟
  基于 TCP 的协议：http/ftp/tls/ws/socks5 可靠性高
- socks 协议
  SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递；当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。
- PAC 代理自动配置 proxy auto-config
  控制网络流量是否走代理服务器
- 加密算法的类型 \*对称加密

  - 加密和解码用到是同一个密码 \*非对称加密（RSA）
  - 加密和解码用的是不同密码
    密钥是一对（公钥加密，私钥解密；私钥加密，共用解密）

- URL(Uniform Resource Locator)
  HASH:URL 的位置标识符，跟在＃符号后面的 URL 部分，包括＃符号
  - 是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP 请求中不包括#
  - 改变#不触发网页重载发送请求
  - onhashchange 事件
  - 改变#会改变浏览器的访问历史
    ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
    │ href │
    ├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
    │ protocol │ │ auth │ host │ path │ hash │
    │ │ │ ├─────────────────┬──────┼──────────┬────────────────┤ │
    │ │ │ │ hostname │ port │ pathname │ search │ │
    │ │ │ │ │ │ ├─┬──────────────┤ │
    │ │ │ │ │ │ │ │ query │ │
    " https: // user : pass @ sub.example.com : 8080 /p/a/t/h ? query=string #hash "
    │ │ │ │ │ hostname │ port │ │ │ │
    │ │ │ │ ├─────────────────┴──────┤ │ │ │
    │ protocol │ │ username │ password │ host │ │ │ │
    ├──────────┴──┼──────────┴──────────┼────────────────────────┤ │ │ │
    │ origin │ │ origin │ pathname │ search │ hash │
    ├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
    │ href │
    └────────────────────────────────────────────────────────────────────────────────────────────────┘
- XSS 跨域整个站点的脚步攻击 Cross Site Scripting
  永远不要把用户输入的东西当做代码执行，可以通过转义客户文本执行
  CSRF 跨站请求伪造 cross site request forgery
  - 浏览器会自动发送其它页面的 cookie 到对应服务器（历史遗留问题）
    现在该问题已经解决，浏览器现在默认不会对跨域请求发送 cookie
  - 通过 referer 头验证请求来源
  - 添加校验 token
  - 通过 js 发送请求，有跨域限制

## HTTP

- 抽象请求

* Ajax
  - Asynchronous JavaScript + XML（异步 JavaScript 和 XML）用来描述一种使用现有技术集合的‘新’方法；JavaScript 执行异步网络请求
  - Axios 是一个基于 promise 的 HTTP 库 ，里面封装了 Ajax 相关功能，可以直接发送 get,post 等请求；支持 promise 和 async/await
    http://www.axios-js.com/docs/ npm install axios
    - 创造一个 axios 实例，实例上配置一些共用的属性，api = axios.create({baseURL:"url 共用前缀地址"，withCredentials:true,解决跨域和 cookie 的冲突})
      export default api
    - axios.get('/user?ID=12345').then()  
      axios.get('/user', {params: {ID: 12345}}).then()
      get 请求的 query 信息可以写在第二个参数里，可以通过 req.query.ID 拿到数据
    - 某个请求的响应包含以下信息
      {
      // `data` 由服务器根据你的请求提供的响应
      data: {},
      // `status` 来自服务器响应的 HTTP 状态码
      status: 200,
      // `statusText` 来自服务器响应的 HTTP 状态信息
      statusText: 'OK',
      // `headers` 服务器响应的头
      headers: {},
      // `config` 是为请求提供的配置信息
      config: {}
      }

- 跨域问题
  - CORS


      * CORS 与 cookie
        * 一个网站只能读取到自己网站服务器的 cookie，cookie 信息按照服务器地址分组储存在浏览器里
        * 一个网站向不是自己的服务器 B 发送请求时，会自动带上服务器 B 的 cookie；
        * 但是在 CORS 中跨域发送请求时默认不带上服务器 B 的 cookie，而且第一次登陆后接收到的 cookie 也不会储存在浏览器
        * 为了解决上面的问题，需要在发送请求时带上 withCredentials：true 这个请求头
        * 如果使用了 Access-Control-Allow-Origin:* ，就不能使用 cookie, 可以改为指定地址
        * express 框架里面可以通过 app.use(cors({})) 中间键配置解决这个冲突,该中间件需要npm cors
          app.use(cors({
              origin:true, 相当于Access-Control-Allow-Origin:*
              maxAge:86400,
              credentials:true,
          }))
    
    * JSONP 一种跨域方案
        通过 script 等标签进行跨域，把请求的数据作为一个函数的参数，引进之后调用函数操作数据；
        给路径传递参数 get 想要的资源
        function jsonp(url, data) {
          return new Promise((resolve, reject) => {
            var script = document.createElement('script')
            var callbackName = 'JSONP_CALLBACK_' + Date.now() + Math.random().toString(16).slice(2)
    
            url = url + '?' + [...Object.entries(data)].map(pair => {
              return pair.join('=')
            }).join('&') + '&callback=' + callbackName
    
            window[callbackName] = function(data) {
              delete window[callbackName]
              document.head.removeChild(script)
              resolve(data)
            }
    
            script.src = url
    
            script.onerror = function(e) {
              delete window[callbackName]
              document.head.removeChild(script)
              reject(e)
            }
    
            document.head.appendChild(script)
          })
        }
        拦截方法：将自带api换为自己包装的
    * 服务器代理  服务器之间的通信没有跨域问题
      * API 代理跨域
          一个网站向不是自己的服务器 B 发送请求时，自己的服务器直接从目标服务器请求信息，把收到的信息发回浏览器，这个是反向代理；
          需要在package.json文件夹里面加上"proxy":目标url; 自己的服务器就可以代理这个url目标服务器
      * 正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；
        而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见


    * Google浏览器的跨域配置
      属性-快捷方式-目标 chrome.exe --disable-web-security --user-data-dir="c:\a\b"

- 运用 HTTP 实现客户端和服务器的通信
  *RPC remote procedure calls 远程过程调用
  http 的协议是通信工具，传递一些参数给服务器，函数在服务器执行
  *RESTful
  通过相关方法操作服务器资源（post/delete/put/get 增删改查）

- 
