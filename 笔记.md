## 作用域

- js 只有函数才能创造作用域；调用函数时要回到创造函数的位置调用，函数里面变量的值不会因为调用函数的位置而发生改变，其初始值是固定的
- 内部作用域可以读取外部作用域里面的变量，外面的作用域不能读取内部作用域里面的变量
- 在任何作用域里面写有一个不用 var 声明的赋值表达式，f = 2 , 那么该变量相当于一个全局变量，相当于 window.f = 2
- 用 let 声明的变量相当于声明了一个块级作用域，即只在离它最近的语句块{}里面生效，外面的语句块无法访问；块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。
- 用 var 声明的变量会提到 var 所在函数作用域的最前面，但是不赋值，到了赋值那一行才赋值
  用 let 声明的变量不会提前，在那行声明就在那行赋值；但在该作用域中，声明完成之前不能使用该变量，以及外部作用域的同名变量，称为 TDZ Temper Dead Zone 暂时性死区；而且在同一个块级作用域里面同一个变量只能用 let 声明一次；
  var a = 8
  {
  console.log(a)
  let a = 9
  } 不会输出 a, 会报错
  const 声明和 let 声明一致，此外 const 声明的变量是一个常量，变量的指向不能改变，如果变量指向一个对象，对象里面的内容可以变；同一个变量只能用 const 声明一次；
- 用 let 和 const 在全局作用域声明的变量也不能通过 window. 属性访问到
  window.length 返回页面中框架的数量（元素 frame 和 iframe）
- 函数的【function 函数名{}】形式定义在 js 中也会提前赋值，会提到函数所在函数作用域的最前面
  函数的【var 函数名 = function{}】形式也会提前声明，但不不赋值，到了赋值那一行才赋值

## 闭包

- 可以访问其他函数内变量的函数，叫做闭包。
- 闭包可以理解为作用域嵌套。作用域里面的函数要访问作用域里面的变量，作用域不能销毁，作用域里面的函数在调用时会产生新的作用域，嵌套在当前作用域里面；
- 函数运行时创建作用域，函数结束时作用域不一定销毁；函数不产生闭包会在结束时销毁；如果还有代码使用作用域里面的变量值，产生了闭包，作用域不会销毁，里面的变量值还是可以被调用它的函数使用；
- 函数本身处在哪个作用域（A），它运行时创建的作用域（B）就在哪个作用域（A）内部；函数本身也是处于一个作用域的。是创建它的函数运行时所创建的作用域。

## 栈

- 单边进，单边出；后进先出，先进后出
- 调用栈：函数遇到其内部函数时先会进入到内部函数里面执行内部函数的代码，等到内部函数的代码执行完毕，再接着执行下面的代码；这种逻辑结构就是调用栈；
- 调用栈的深度：函数的内部函数的内部函数的内部函数这种调用方式体现了调用栈的深度，即函数展开的层次；如果调用栈超过了其深度会发生栈空间溢出；
- 调用栈不一定产生闭包，因为兄弟函数之间也可以互相调用，此时他们共用一个父函数的作用域
- 调用栈展开的层次也是一种树状结构

## 函数

- 副作用：打印了一段输出或者修改了全局变量
  返回值：纯函数，通过参数产生值，不读取全局变量，值仅由其参数决定
- ducument.write() 向文档的解析流里写入内容，文档一解析完</html>，解析流关闭；重新 document.write 会导致重新打开一个解析流，之前 html 的内容会被冲掉，js 运行后创建的函数及变量是没有冲掉的
  ducument.open() 打开解析流，打开页面时默认打开
  ducument.close() 关闭解析流，关闭页面时默认关闭
- 形参 ：函数定义的参数
  实参 ：函数实际传递的参数
- 函数的相关方法
  fun = function(){}
  - fun.apply(null,array) ==fun(...array)
    将数组里面的参数一次性传递给函数
  - fun.length =>形参的个数
  - fun.toString() 函数的源代码
  - fun.name =>函数的名字





## 对象

- 数组是值的有序集合
  对象是值的具有名字的集合
- 对象的相关方法

  - Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致。
  - for in 的迭代顺序
    - 先按照大小顺序迭代整数属性名
    - 之后迭代其它属性，按照添加顺序
  - Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）, 这个方法也可以用于数组和字符串
    const obj = { foo: 'bar', baz: 42 };
    console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]
  - Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
    const target = { a: 1, b: 2 }
    const source = { b: 4, c: 5 }
    const returnedTarget = Object.assign(target, source)
    console.log(target) =>{ a: 1, b: 4, c: 5 }
    console.log(returnedTarget) => { a: 1, b: 4, c: 5 }
    -Object.getOwnPropertyDescriptor(obj, propertyName)
    返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）

- 当一个对象和原始数据类型==对比时，会调用对象上面的 valueOf 方法,其返回值进行对比

- null 和 undefined 没有属性，其它所有数据类型的值都有属性
- 包含函数的属性称为某个值的方法
- obj【表达式】：表达式的返回值作为对象选中的属性名，也可以传递一个变量；obj【变量】
  object.property
  object['property'] 注意里面是个字符串
- 现代引擎中，关键字 / 数值 做为对象属性名也可以不加引号
  { 1:2, 0: 3, for: 8, while: 9, foo: 10, "2abc": 3, 'hello world': 9}
- 用 == 或者 === 判断对象是否相等时，只有两个对象都指向同一个内存地址的对象实体才为 true，其它的即使两个对象内容，值一样但是指向的对象实体不一样会返回 false；
  而原始数据类型 Number ，String，Boolean 作相等比较时只比较值，而不管指向地址
- obj1 = obj2 这句代码是使 obj1 指向 obj2 的对象实体，所以 obj1 === obj2；这种情况改变对象实体里面的内容，两个对象都发生了改变
- 原始数据类型 Number，String，Boolean 的值是固定的，不能再添加属性，但是添加了也不会报错
- 原始数据类型 Number，String，Boolean 直接当做对象来添加属性"XX"时，会短暂的生成一个新的对象 A, 在 A 中添加属性"X"，之后 A 会被清理掉；当要读取这个添加的属性"X"时，又会短暂的生成一个新的对象 B, 在 B 中读取属性"X", 返回 undefined，之后 B 被清理掉；
  如：123.ab = 1 会在 A 对象中添加 ab 属性，之后消失
  console,log(123.ab) 会在 B 对象中寻找 ab 属性，返回 undefined
- 包装对象：1 个真实的对象包装了一个原始数据，如 Objiect() 函数强行将其他类型转化为对象； Object(1);Object("123"})
  原始对象 / 原生对象：直接声明的对象 ；asd = {}
- 全局作用域中只有一个全局对象 window, 所有的全局属性都在 window 对象里面，window 对象的任何属性都指向属性本身，window 对象的 window 属性指向 window 对象本身
  window.window===window
  window.console===console
- 对象的浅对比：=== 是作浅比较，只检查左右两边是否是同一个对象的引用
  对象的深对比：不仅是同一个对象的引用，而且是同一个链表

## 数组

- 判断两个纯数字数组里面的内容是否相同，先 array.sort(function(a,b){return a - b}) 从小到大排序，再 join() 转化为字符串作全等判断
- 数组相关方法
  - arr = Array.from(arrlike) 从一个（类似）数组或可迭代对象中创建一个新的，浅拷贝的数组实例
  - Array.isArray(arr) 判断 arr 是否是数组
  - arr.fill(value ，start，end) 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。
  - arr.flat(depth) flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中 的元素合并 为一个新数组返回；depth 默认 1
  - arr.includes(value) 方法用来判断一个数组是否包含一个指定的值，也可以判断是否有 NaN，根据情况，如果包含则返回 true，否则返回 false。注意：对象数组 [{},{}] 不能使用 includes 方法来检测。
  - arr.indexOf() 返回下标，不能判断 NaN，会返回 -1
  - find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。
    findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回 -1。
  - reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。
  - some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值。
    every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。
  - 数组的 toString 方法[1,2,3].toString()=>'1,2,3'
- ES6 数组去重的最佳实践：Set 结合 Array.from()
  var a = [1,1,2,2,4,4]
  var b = new Set(a)
  var c = Array.from(b) =>[1,2,4]
  var d = b.size =>3（不同项个数）
- 数组的高阶函数作为方法调用时（each,map,every 等等）, 可以加一个参数表示为第一个参数的他 this
  [1,2,3].map(f(),obj)=>obj 是 f() 的 this
- 数组的冒泡排序最优解 每次把最值放到最后
  function swap(ary, i, j) {
  if (i != j) {
  var t = ary[i]
  ary[i] = ary[j]
  ary[j] = t
  }
  }
  function bubbleSort(ary) {
  for(var j = ary.length - 2; j >= 0; j--) {
  var swapped = false
  for(var i = 0; i <= j; i++) {
  if (ary[i] > ary[i + 1]) {
  swap(ary, i, i + 1)
  swapped = true
  }
  }
  if (!swapped) {
  break
  }
  }
  return ary
  }
- 数组的归并排序
  function mergeSort(ary) {
  if (ary.length < 2) {
  return ary
  }
  var mid = ary.length >> 1
  var left = ary.slice(0, mid)
  var right = ary.slice(mid)
  mergeSort(left)
  mergeSort(right)
  var i = 0
  var j = 0
  var k = 0
  while(i < left.length && j < right.length) {
  if (left[i] < right[j]) {
  ary[k++] = left[i++]
  } else {
  ary[k++] = right[j++]
  }
  }
  while (i < left.length) {
  ary[k++] = left[i++]
  }
  while (j < right.length) {
  ary[k++] = right[j++]
  }
  return ary
  }
- 数组的选择排序 每次遍历将最小值放到前面
  function swap(array, i, j) {
  let temp = array[i]
  array[i] = array[j]
  array[j] = temp
  }
  function selectSort(ary) {
  for (let i = 0; i < ary.length - 1; i++) {
  var minPos = i
  for (let j = i + 1; j < ary.length; j++) {
  if (ary[minPos] > ary[j]) {
  minPos = j
  }
  }
  swap(ary, i, minPos)
  }
  return ary
  }
- 数组的插入排序（将无序的部分插入到有序部分），利用排序二叉树，先将数组转化为排序二叉树，再 将二叉树遍历得到排序数组
  function insertIntoBST(root, val) {
  if (!root) {
  return new TreeNode(val)
  }
  if (root.val <= val) {
  root.right = insertIntoBST(root.right, val)
  } else {
  root.left = insertIntoBST(root.left, val)
  }
  return root
  }
  function bstSort(ary) {
  let root = ary.reduce(insertIntoBST, null)
  let i = 0
  inOrderTraverse(root, val => { ary[i++] = val })
  return ary
  }
- 数组的原地快速排序
  对应所有元素完全相同的数组，性能退化为 n*n , 调用栈深度为 n
  方法： 数组中随机取一个数 s 和最后一位交换位置；双指针从头开始遍历数组，快指针遇到比 s 小的就和慢指针交换位置，如此就可以遍历一遍后比 s 小的都在 s 左边，s 相当于排序了。然后递归操作
  function quickSort(ary, start = 0, end = ary.length - 1) {
  function swap(array, i, j) {
  if (i != j) {
  let t = array[i]
  array[i] = array[j]
  array[j] = t
  }
  return array
  }
  if (end - start <= 0) { return ary }
  let pivotIndex = start + Math.random() * (end - start + 1) | 0
  let pivotNumber = ary[pivotIndex]
  swap(ary, pivotIndex, end)
  let i = start, j = start
  for (; j < end; j++) {
  if (ary[j] < pivotNumber) {
  swap(ary, i, j)
  i++
  }
  }
  swap(ary, i, end)
  quickSort(ary, start, i - 1)
  quickSort(ary, i + 1, end)
  return ary
  }
- // 排序前后不改变相同元素的相对位置，则称为稳定的排序算法
  // 反之，则为不稳定的
  // 不稳定的排序算法：选择排序，就地快排
  // 稳定的排序算法：冒泡，归并，插入排序，bst 排序
- 数组的 sort 方法
  function qSort(ary, compare) {
  return quickSort(ary, compare)
  // 分治 divide and conquer
  function quickSort(ary, compare, start = 0, end = ary.length - 1) {
  if (end - start <= 0) {
  return ary
  }

  var pivotIndex = Math.floor(Math.random() \* (end - start + 1) + start)
  var pivot = ary[pivotIndex]

  swap(ary, pivotIndex, end)

  var i = start
  for(var j = start; j < end; j++) {
  if (compare(ary[j], pivot) < 0) {
  swap(ary, i, j)
  i++
  }
  }

  swap(ary, i, end)

  quickSort(ary, compare, start, i - 1)
  quickSort(ary, compare, i + 1, end)

  return ary
  }
  }

## 循环

- for 循环中 var 定义的变量是循环所在作用域变量，即作用域里面循环后面的代码可以引用 i 的值
  如果想变量只对 for 循环生效，用 let 定义 for 循环的变量，let 定义的变量属于严格模式，只在对应的区域块生效。
- for in 循环
  for(let 变量 in obj){} 将对象里面的属性名依次赋值给变量，每赋值一次循环一次
- for of 循环 遍历可迭代对象定义要迭代的数据。
  for...of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

## 链表结构

- 每个结点存储下一个点的位置的数据结构
  易增删，难查找，不连续占用内存
- 数组转化为链表
  - 方法 1
    - 首先遍历数组一次创造 n 个节点对象 node，value = Arr[i],next = null,node 全部 push 到数组 nodes 中
    - 接着再遍历数组 nodes 一次，将节点链接在一起，nodes[i].next=nodes[i+1]
  - 方法 2
    - 创建一个头部节点，使其 next 属性指向下标为 i 的节点，一次循环下去
      function arrTolist(arr) {
      let head = {
      value: undefined,
      next: null
      }
      let remmber = head
      for (let i = 0; i < arr.length; i++) {
      node = {
      value: arr[i],
      next: null
      }
      head.next = node
      head = node
      }
      return remmber.next
      }
  - 方法 3 递归
    - function arrayToList(arr){
      if(arr.length==0){
      return null
      }
      return {
      value:arr[0],
      next:arrayToList(arr.slice(1))
      }
      }
- 链表转化为数组

  - function listToArray(list){
    let result = []
    while(list != null){
    result.push(list.value)
    list = list.next
    }
    return result
    }

  - function listToArray2(list){
    if(list == null){
    return []
    }
    let tail = list.next
    return [list.value,...listToArray2(tail)]
    }

- 在某个节点前面插入一个值为 value 的新节点 (index 是下标号）
  function insert(list, index, value) {
  if (index < 0) {
  index = 0
  }
  下标小于 0 时就相当于 0
  if (!list) {
  return {
  value: value, next: null
  }
  }
  如果 list 是空节点，那就是在 null 前面加入一个新节点，index 只能为 0，返回其值
  if (index == 0) {
  return {
  value: value,
  next: list
  }
  }
  如果 index 为 0，即在 list 前面加一个节点
  var head = list 用 head 保存头节点
  var idx = -1 用 idx 记录下标

  while (idx != index - 1 && list.next) {
  idx++
  list = list.next
  }
  如果下标没有到达目标位置且 list.next 不为 null
  循环 idx 递增，list=list.next

  list.next = {
  value: value,
  next: list.next,
  }
  指针到达目标位置时，list.next 指向新节点，新节点又指向原来 list.next 的值
  return head
  }

- 链表的反转
  反转 head 后面的链表，再把反转的链表指向 head
  var reverseList = function (head) {
  if (!head || !head.next) { return head }
  let newHead = reverseList(head.next)
  head.next.next = head
  head.next = null
  return newHead
  };
- 链表的归并
  - 循环
    function mergeTwoLists(l1, l2) {
    let hummy = new ListNode()
    let hummy2 = hummy
    while (l1 && l2) {
    if (l1.val < l2.val) {
    hummy2.next = l1
    l1 = l1.next
    } else {
    hummy2.next = l2
    l2 = l2.next
    }
    hummy2 = hummy2.next
    }
    hummy2.next = l1 || l2
    return hummy.next
    }
  - 递归
    var mergeTwoLists = function (l1, l2) {
    if (!l1 || !l2) {
    return l1 || l2
    }
    if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2)
    return l1
    } else {
    l2.next = mergeTwoLists(l1, l2.next)
    return l2
    }
    }
- 链表的排序
  先递归二分再归并
  var sortList = function (head) {
  if (!head || !head.next) {
  return head
  }
  let hummy = new ListNode()
  hummy.next = head
  let slow = hummy
  let fast = hummy
  while (fast && fast.next) {
  slow = slow.next
  fast = fast.next.next
  }
  let left = head
  let right = slow.next
  slow.next = null
  left = sortList(left)
  right = sortList(right)
  function mergeTwoLists(l1, l2) {
  let hummy = new ListNode()
  let hummy2 = hummy
  while (l1 && l2) {
  if (l1.val < l2.val) {
  hummy2.next = l1
  l1 = l1.next
  } else {
  hummy2.next = l2
  l2 = l2.next
  }
  hummy2 = hummy2.next
  }
  hummy2.next = l1 || l2
  return hummy.next
  }
  return mergeTwoLists(left, right)
  };

## 哈希表

- 解决哈希表冲突
  - 扩容：数组中位置占用率超过某个值后数组扩容
  - 开放地址法：用两个数组，一个储存 key 一个储存映射值
  - 链表储存：数组储存链表，下标相同的 key 储存在同一个链表中，链表储存 key,value,next 3 个值
  - 多个哈希函数换着用：发生冲突换另外一个哈希函数
- 哈希表的查找效率 O(1) 将 keys 通过哈希函数转化为独一无二的数值储存在数组中，空间换时间。
- 哈希表的应用
  md5;sha1；对文件进行哈希映射
  垃圾邮件过滤，利用计算机中的位图结构
  位图：指一个由 0 和 1 组成的超大数组 [0,1,0,1,1,1,0......]

## 二叉树

- 完全二叉树在数组中表示
  对于下标为 i 的节点对于的左节点为 2i+1, 右节点为 2i+2
  对于下标为 n 的节点，其对应的父节点为 Math.floor((n-1)/2)

- 二叉树的排序插入
  var insertIntoBST = function (root, val) {
  if (!root) {
  return new TreeNode(val)
  }
  if (root.val > val) {
  root.left = insertIntoBST(root.left, val)
  } else {
  root.right = insertIntoBST(root.right, val)
  }
  return root
  };
- 利用二叉树对数组排序
  向将数组转化为排序二叉树（左边的节点一定比右边小），再中序遍历二叉树，将值储存在数组中就是排序的结果
  function bstSort(ary) {
  var root = ary.reduce(insertIntoBST, null)
  k = 0
  inOrderTraverse(root, val => {
  ary[k++] = val
  })

  return ary
  }

- 前中后序遍历
  前序遍历 根节点 左子数 右子数 看书看过的顺序
  function preOrderTraverse(root, action) {
  if (root) {
  action(root.val)
  preOrderTraverse(root.left, action)
  preOrderTraverse(root.right, action)
  }
  }
  中序遍历 左子数 根节点 右子数 看书看过一半的顺序 由左往右扫描
  function inOrderTraverse(root, action) {
  if (root) {
  inOrderTraverse(root.left, action)
  action(root.val)
  inOrderTraverse(root.right, action)
  }
  }
  后续遍历 左子数 右子数 根节点 看书看完的顺序
  function postOrderTraverse(root, action) {
  if (root) {
  postOrderTraverse(root.left, action)
  postOrderTraverse(root.right, action)
  action(root.val)
  }
  }

- 将数组转化为二叉树
  _方法一： 递归
  function arrayToTree(array, rootPos = 0) {
  if (array[rootPos] == null) {
  return null
  }
  return {
  val: array[rootPos],
  left: arrayToTree(array, rootPos _ 2 + 1),
  right: arrayToTree(array, rootPos * 2 + 2)
  }}
  *方法二 队列 创造一个储存数组，先进先出，使用 shift 和 push 方法达到效果
  function arrayToTree2(array) {
  if (array.length == 0) { return null }
  let root = new TreeNode(array[0])
  let nodes = [root]
  for (let i = 1; i < array.length; i++) {
  let current = nodes.shift()
  if (array[i] != null) {
  let node = new TreeNode(array[i])
  current.left = node
  nodes.push(node)
  } else {
  current.left = null
  }
  i++
  if (i == array.length) {
  break
  }
  if (array[i] != null) {
  let node = new TreeNode(array[i])
  current.right = node
  nodes.push(node)
  } else {
  current.right = null
  }
  }
  return root}

- 将二叉树转化为数组
  - 方法一 递归
    function treeToArray(root, pos = 0, result = []) {
    if (root) {
    result[pos] = root.val
    treeToArray(root.left, pos _ 2 + 1, result)
    treeToArray(root.right, pos _ 2 + 2, result)
    }
    return result}
  - 方法二 层次遍历 队列 队列里面没有值时循环结束
    function treeToArray2(root) {
    if (root==null ) { return [] }
    let result = []
    let nodes = [root]
    while (nodes.length) {
    let current = nodes.shift()
    if(current){
    result.push(current.val)
    nodes.push(current.left,current.right)
    }else{
    result.push(null)
    }
    }
    while(result[result.length - 1] === null) {
    result.pop()
    }
    return result}
  - 方法三 层次遍历
    function treeToArray3(root) {
    if (root) {
    var result = [root.val]
    var nodes = [root]
    while (nodes.length) {
    var curr = nodes.shift()
    if (curr.left) {
    result.push(curr.left.val)
    nodes.push(curr.left)
    } else {
    result.push(null)
    }
    if (curr.right) {
    result.push(curr.right.val)
    nodes.push(curr.right)
    } else {
    result.push(null)
    }
    }
    while(result[result.length - 1] === null) {
    result.pop()
    }
    return result
    }
    }

## 堆（Heap）

- 堆内存：对于大小无法确认的数据，计算机储存其内存地址，其本体储存在堆内存中
  栈内存（空间）：指储存正在等待调用返回函数的局部变量的一片的内存，其储存是连续的，大小是确定的
  调用栈：函数之间互相调用的逻辑关系
- 堆是一种数据结构，也叫优先队列（PriorityQueue），和堆空间没有任何关系
- 堆的结构
  - 堆是一个完全二叉树
  - 每个节点都比其子节点要大（小）
  - 根节点一定是最大（最小）值
- 对于堆，主要支持两种操作
- 往堆里面增加元素
- 从堆里面取出其最值
- 两种操作都要保证堆的结构
- 代码
  大堆
  class deap {
  constructor(nums) {
  this.elements = nums
  this.heapfy(nums)
  }
  add(val) {
  this.elements.push(val)
  this.heapUp(this.elements.length - 1)
  }

  heapUp(currIdx) {
  while (currIdx > 0) {
  let pIdx = (currIdx - 1) >> 1
  if (this.elements[pIdx] < this.elements[currIdx]) {
  this.swap(pIdx, currIdx)
  currIdx = pIdx
  } else {
  break
  }
  }
  }
  // 将某个节点的父节点调整为堆，且保持整个堆结构

  heapdown(currIdx, end = this.elements.length) {
  while (currIdx < end) {
  let maxIdx = currIdx
  let leftIdx = currIdx \* 2 + 1
  let rightIdx = leftIdx + 1
  if (leftIdx < end && this.elements[leftIdx] > this.elements[maxIdx]) {
  maxIdx = leftIdx
  }
  if (rightIdx < end && this.elements[rightIdx] > this.elements[maxIdx]) {
  maxIdx = rightIdx
  }
  if (this.elements[maxIdx] != this.elements[currIdx]) {
  this.swap(maxIdx, currIdx)
  currIdx = maxIdx
  } else {
  break
  }
  }
  }
  // 将某个节点调整为堆，且保持整个堆结构
  heapfy() {
  let curr = (this.elements.length - 2) >> 1
  for (let i = curr; i >= 0; i--) {
  this.heapdown(i)
  }
  }
  // 从不是叶子节点开始进行倒序 headdown 操作，得到了整个堆结构数组

  swap(i, j) {
  let temp = this.elements[i]
  this.elements[i] = this.elements[j]
  this.elements[j] = temp
  }

  SortArray(arr){
  this.heapify(ary)
  for(var i = ary.length - 1; i > 0; i--) {
  this.swap(ary, i, 0)
  this.heapdown(0)
  }
  return ary
  }

  push(val){
  this.elements.push(val)
  this.heapUp(this.elements.length - 1)
  }
  // 在末尾添加元素

  pop(){
  var result = this.elements[0]
  var last = this.elements.pop()
  if (this.elements.length == 0) {
  return result
  }
  this.elements[0] = last
  this.heapdown(0)
  return result
  }
  // 取出堆顶

## 回溯算法

- 有条件的穷举，当有条结果满足结束条件时将其记录下来
- depth first search 尝试所有可能，符合条件走下一步，不符合条件回到上一步，直到所有符合条件的路径都尝试
- 回溯条件：判断是否进行下一步的条件
- 结束深度搜索条件：深度搜索结束，将一种可能结果记录下来
- 删除路径：找到满足条件的路径后删除最后一步寻找更多的可能
- // leetcod 77 78 17 22
  // 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合
  var combine = function (n, k) {
  let res = []
  if (n < k) {
  return res
  }
  function backtrack(result, n, k) {
  if (result.length === k) {
  res.push(result.slice())
  return // 结束条件，返回上一层
  }
  for (let i = n; i > 0; i--) {
  result.push(i)
  backtrack(result, i - 1, k) 深度搜索
  result.pop() 找到满足条件的路径后删除最后一步寻找更多的可能
  }
  }
  backtrack([], n, k)
  return res
  }

## 算法技巧

- 进制转换
  var n = 3123
  while(n > 0){
  var digit = n % 2
  console.log(digit)
  n = (n - digit)/2
  }
- 判断素数的简化方法
  - 遍历到根号 n 即可
  - 前面再加一些判断缩小范围，比如能不能被 2,3,5，7 等整除
    var isPrime = function(n) {
    if (n < 2) {
    return false
    }
    var sqrt_n = Math.floor(Math.sqrt(n))
    for(var i = 2; i <= sqrt_n; i++) {
    if (n % i == 0) {
    return false
    }
    }
    return true
    }
  - 利用正则表达式判断
    function isPrime(n) {
    return !/^(?=(.{2,})\1+\$)/.test('x'.repeat(n))
    }
  * 素数两性定理
    把素数分为 6 列，素数全部存在于第 1 列和第 5 列（2 和 3 除外）；第 2，4 列全部能被 2 整除。第 3，6 列全部能被 3 整除
  * 算法中递归优雅易懂，但是耗时；超时可以转化为循环语句
  * 记录递归深度的技巧
    depth = 0
    var levelOrder = function(root) {
    depth++
    if (root) {
    if (depth in result) {
    result[depth].push(root.val)
    } else {
    result[depth] = [root.val]
    }
    levelOrder(root.left)
    levelOrder(root.right)
    }
    depth--
    }
- 递归下降，解析语法数
  leetcode 1106. 解析布尔表达式
  var parseBoolExpr = function(expr) {
  var i = 0
  return parse()
  function parse() {
  if (expr[i] == 't') {
  i++
  return true
  }
  if (expr[i] == 'f') {
  i++
  return false
  }
  if (expr[i] == '!') {
  return parseNot()
  }
  if (expr[i] == '&') {
  return parseAnd()
  }
  if (expr[i] == '|') {
  return parseOr()
  }
  }

  function parseNot() {
  i += 2
  var value = parse()
  i++
  return !value
  }

  function parseAnd() {
  i += 2
  var result = true
  while (true) {
  var value = parse()
  result = result & value
  if (expr[i] == ')') {
  i++
  break
  }
  if (expr[i] == ',') {
  i++
  }
  }
  return result
  }

  function parseOr() {
  i += 2
  var result = false
  while (true) {
  var value = parse()
  result = result || value
  if (expr[i] == ')') {
  i++
  break
  }
  if (expr[i] == ',') {
  i++
  }
  }
  return result
  }
  }

## ES6 相关知识

- https://leanpub.com/understandinges6/read#leanpub-auto-default-values-in-modules
- ES6 标准里形参的声明都是默认为用 let 声明
- 剩余参数（参数 1， ... 剩余参数）只能写在最后
  function addEntry(squirrel, ...events) {
  return {
  squirrel: squirrel,
  events: events,
  }
  }
- 参数的默认值 （属性 = 默认值）
  function slice(array,start = 0,end = array.length){}
- 展开运算符 (... 将数组两边的【号和】号中合掉） 不能单独使用，作为参数使用
  Math.max(...[1,2,3]) == Math.max(1,2,3) =>3
- class 语法 ，也就是构造语法糖
  将一类功能对象封装；class 类名{}

  - 这样写的好处

  * 里面的方法默认是不可枚举的
  * 不使用 new 会报错
  * 方便继承

  - constructor() {} 构造函数
    static 用来定义一个类的一个静态方法。调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法；方法放在类上而不是实例 this, 减少原型链压力
    各种方法直接写在{}里面
    里面不要加，号和；号
  - class B extends A B 类继承 A 类
    B.prototype._proto_ === A.prototype
    B._proto_ === A
    B 类可以直接用 A 的方法，注意不要命名和父类的同名方法，会覆盖父类方法，原型污染
    super() 调用父类构造函数，先构造一个父类的实例，然后将 this 绑定到这个实例上，所以 super() 调用之前不能使用 this
    继承时在构造函数中需要调用 super，super 相当于父类的构造函数，后面也可以直接接父类的方法 super.method
    B 类如果不写构造函数也行，会默认写
    constructor(...arg) {
    super(...arg)
    }

- class A {
  static a(){}
  static b(){}
  constructor(){}
  method1(){}
  method2(){}
  get length(){}
  set length(val){}
  }

- class Queue {
  static from(ary) {
  var q = new Queue()
  for (var val of ary) {
  q.add(val)
  }
  return q
  }

      constructor(initVals) {
          this._head = null
          this._tail = null

          for (var val of initVals) {
              this.add(val)
          }
      }

      add(val) {
          var node = {
              val: val,
              next: null,
          }
          if (this._head == null) {
              this._head = this._tail = node
          } else {
              this._tail.next = node
              this._tail = node
          }
          this._size++
          return this
      }

      remove() {
          if (!this._head) {
              return undefined
          }
          this._size--
          var node = this._head
          this._head = this._head.next
          if (this._head == null) {
              this._tail = null
          }
          return node.val
      }

      get size() {
          return this._size
      }

  }

- 解构语法
  [a,b]=[b,a] a 和 b 互换位置
  {a，b} = {a:1,b:2} 拿到 a 和 b
- 模板字符串 ``
  - 用反引号（``）来表示，模板字符串可以包含特定语法（\${expression}）的占位符； `${354}a${6}sfdf${12}safs${5+2}daf${2\*1}dsaf` => "354a6sfdf12safs7daf2dsaf"
  - 模板字符串开头如果有一个函数表达式，该函数称为模板字符串的标签函数，它会在模板字符串处理后被调用
    fun `${354}a${6}sfd\f${12}\sa${5+2}da${2*1}df`
  - 标签函数 fun 的 arguement 为
    第一个元素为一个数组，里面是由占位符分割的字符串组成的，再加上 raw 属性，占位符
    [["","a","sfdf","sa","da","df",row:["","a","sfd\f","\sa","da","df"]],
    "354","6","12","7","2"
    ]
  - 在标签函数的第一个参数中，存在一个特殊的属性 raw ，我们可以通过它来访问模板字符串的原始字符串，而不经过特殊字符的替换。
- 伪调用 可以优化调用栈，防止爆栈
  function(){
  var a = 1
  return g(a)
  }
- 模块的导入导出
  - 模块的导出
    - export var color = "red";
    - export function sum(num1, num2) {
      return num1 + num1;
      }
    - export class Rectangle {
      constructor(length, width) {
      this.length = length;
      this.width = width;
      }
      }
  - 模块的导出 import { identifier1, identifier2 } from "./example.js";
    import {color，sum,Rectangle} form path
  - 模块的导入和导出都需要写在最外层作用域，不能嵌套到其它作用域，方便静态分析
  - 可以设置一个默认的导出，当导入一个没有的模块名时就导入这个默认的
    export default function(num1, num2) {
    return num1 + num2;
    }
  - 要引入到 type 为 module 的 script 标签里<script type = 'module'>
- 私有属性的实现
  如果一个对象还有指针指向，它就不会被垃圾回收
  弱引用，如果一个对象仅仅被 weakMap/WeakSet 内部指向时，它可以被垃圾回收
  var C = (function(){
  var classProperties = new WeakMap()
  return class A {
  constructor(name, age) {
  var \_this = {}
  \_this.age = age
  \_this.name = name

        classProperties.set(this, _this)
      }
      getName() {
        var _this = classProperties.get(this)
        return _this.name
      }

  }
  }())
  var c = new C()
  c = null

- Proxy 代理
  对对象属性的读取设置(get,set)，方法调用等等的拦截

## 高阶函数

- forEach 函数

  - 源代码
  function forEach(array,action){
  for(let i = 0;i< array.length;i++){
  action(array[i], i, array)
  }}
  array.forEach(function(){}) 方法从头至尾遍历数组，为每个元素调用指定的函数。
  action 最多可以传递 3 个有效的参数 (arr[i]，索引，数组），修改原数组只能通过第二个和第三个参数修改
  forEach 只有一个参数时，即每个元素的处理函数。
  <!--  var numbers = [1, 2, 3];
   numbers.forEach(x => console.log(x));
   // 同等于
   numbers.forEach(function (x) {
       console.log(x); -->

- filter 函数 返回新数组

  - 源代码
  function filter(array, test) {
  let result = []
  for (let i = 0; i < array.length; i++) {
  if (test(array[i], i, array)) {
  result.push(array[i])
  }}
  return result}
  array.filter(function(){}) filter 函数的作用是遍历该集合，然后将该集合中符合某些特定条件的元素组成新的数组，并返回该新数组。
  test 最多可以传递 3 个有效的参数 (arr[i]，索引，数组）
  filter 只有一个参数时，即判断所有元素是否符合条件的处理函数。
  <!--  var digits = [1, 4, 5, 10, 15]
  var even = digits.filter(function (number) { return number % 2 == 0 })
  console.log(even))
  // [4, 10] -->

- map 函数 返回新数组 \*源代码
  function map(array, mapper) {
  let result = []
  for (let i = 0; i < array.length; i++) {
  result.push(mapper(array[i], i, array))
  }
  return result}
  array.map(function(){}) 对数组的每个元素调用定义的回调函数并返回包含结果的数组
  mapper 最多可以传递 3 个有效的参数 (arr[i]，索引，数组）
  map 只有一个参数时，及给出映射关系的处理函数
    <!-- var array = [16,25,36];
    array.map(Math.sqrt);
    //array = [4,5,6]

    var array = [11, 22, 33, 44, 55];
    console.log(array.map(function (n) { return n % 10 }))
    //array = [1,2,3,4,5] -->

      * reduce 函数 返回最终运算的结果
        * reduce 源函数
            function reduce(arr, reducer,initalVal=arr[0] ) {
              var  i = 0
              if (argument.length===2){
                i=1
              }
              for (; i < arr.length; i++){
                  initalVal = reducer(initalVal,arr[i]，index,arr)
              }
              return initalVal
            }
        * reduce 可以接受 3 个参数，数组（作为数组的方法时可以省去），reducer 函数，初始值（不设置时默认为数组第一项）； reducer 是必要参数，其它可选
        * 执行函数 reducer 接受 4 个参数，initalVal（上一次执行结果，第一次为初始值）arr[i] 数组的第 i 项，数组下标，数组本身（作为数组的方法时可以省去）；initalVal 和 arr[i] 是必要参数，其它可选

        Array 的 reduce() 把一个函数作用在这个 Array 的 [x1, x2, x3...] 上，这个函数必须接收两个参数，reduce() 把结果继续和序列的下一个元素做累积计算，其效果就是：
        [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
       <!--  var arr = [1, 3, 5, 7, 9];
        arr.reduce(function (x, y) {
        return x + y;
        }); // 25 -->

      * sort 函数
        用于数组的排序，返回值大于 0 交换位置，其它位置不变
        array.sort(function(a,b){return a - b})  从小到大排序
        array.sort(function(a,b){return b - a})  从大到小排序

      * bind: 绑定 this 和参数 ，参数传多了只接受前面的参数，后面的参数无效；且 this 只能绑定一次，多次绑定不生效
        apply: 设定 this 和参数，参数以数组形式传入
        call: 设定 this 和参数，参数不能以数组的形式传入
        如果只绑定参数而不指定 this, 通常将 this 设置为 null，新的绑定函数不使用 this 即可

      function myBind(thisArg, ...fixedArgs){ <!-- thisArg 是 this 要绑定参数，fixedArgs 是其它的参数 -->
        let self = this <!-- 谁调用了这个函数谁就是 this -->
        return function bound(...arguments){
          fixedArgs.push(...arguments)<!-- 合并其它参数 -->
          if(new.target=== bound){
            return new self(...fixedArgs)

          <!-- 如果是构造函数调用了 mybind 函数，提供的 this 就会被忽略，thisArg 会被忽略掉；其它的参数会参与绑定，并且返回一个新的构造函数 -->

          }else{
          return self.apply(thisArg,fixedArgs)
          }
        }
      }

## 对象原型

- 基本关系
  几乎任何对象有原型的‘原型’指用来查找属性的 fallback 对象：obj.**proto**/Object.getPrototypeOf(obj)，称为“原型”
  每个函数（且一般只有函数才有）都有一个原型属性指的是 F.prototype（我的实例的原型），称为“原型属性”

  函数的原型是函数的构造函数的原型属性
  Function.**proto** ===Function.prototype
  String.**proto** ===Function.prototype
  Number.**proto** ===Function.prototype
  Object.**proto** ===Function.prototype

- 构造函数 var f = new Function()

  - new 运算符会进行如下的操作：
    创建一个空的对象 A{}，A 的原型是构造函数 F 的原型属性
    将 this 绑定到新创建的对象 A，并且用指定的参数调用构造函数修改该对象。
    如果该函数没有返回值，则返回 this
    如果该函数有返回值但是返回的不是对象时，还是返回 this
    如果该函数返回的是对象时，返回该对象
  - new.target === 构造函数
    new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。
  - new 的优先级比较高，比。号高
  - new 后面接一个函数时，如果函数没有参数直接调用，（）可以省去

- 原型

  - 每个函数的原型属性默认指向空的对象{}，该空对象的原型是 Object.prototype
    f.prototype -> {} -> Object.prototype -> null

  - constructor 属性 ，该属性指向了用于构造此实例对象的构造函数。
    Foo.prototype.constructor === Foo
    f1.**proto**.constructor === Foo

  - 判断一个值的原型是谁就看其本身是什么类型，然后找到其类型的构造函数的原型属性
    Object.getPrototypeOf([1]) === Array.prototype
    Object.getPrototypeOf({"a":2}) === Object.prototype
  - null ,undefined 没有原型
  - Object.prototype 的原型是 null, 一般也认为其也没有原型

  - JS 原生的几个构造函数的原型属性是其第一个实例，历史遗留问题
    Object.prototype.toString.call(String.prototype)==="[object String]"
    Object.prototype.toString.call(Function.prototype) === "[object Function]"

- 可以通过 Object.prototype.toString.call（类型）判断数据类型，会返回"[object 数据类型】"
  （这种判断方式只能判断原生类型，自己写的构造函数创建的实例都会返回"[object Object]")
  Object.prototype.toString.call([]) ==="[object Array]"
  Object.prototype.toString.call(null) === "[object Null]"
  Object.prototype.toString.call(undefined)==="[object Undefined]"
- instanceof 判断一个对象是不是构造函数的实例 person instanceof Person
  可以在原型中寻找判断
- typeof 用来判断原始数据类型
  Object.prototype.toString.call 用来判断内置对象类型
  instanceof 用来判断自定义对象类型（构造函数）

- this

  - 当一个函数以方法的形式被调用时，如 array.length，函数的 this 就是调用它的对象
  - 以纯函数形式调用时，this 就是 window f()
  - 但用 new 来调用 this 时，this 就是那个新建的对象； 如构造函数；
  - this 永远不能被赋值，即 this 不能写在等号左边
  - this 永远指向一个对象，如果指向了一个原始数据类型会将原始数据类型包装成对象
  - 箭头函数不会创建自己的 this, 它只会继承自己的作用域链的上一层作用域的 this 对象

- this 的丢失问题
  this 指向调用的对象与函数声明的位置无关，只与调用位置有关，如果在调用位置还使用声明位置的 this，this 会丢失；解决方法通过 bind 绑定 this 或者通过箭头函数，箭头函数的 this，总是指向定义时所在的对象，而不是运行时所在的对象。

- 不能通过操作对象来改变对象的原型的属性，可以直接操作对象的原型
  obj.**proto**. 属性名 = 属性值

- Object.getPrototypeOf(obj) == obj.**proto**
  Object.prototype 所有原型对象的根，其没有原型
  Function.prototype 所有函数原型的根
  Array.prototype 所有数组原型的根
  Function.prototype 的原型是 Object.prototype , 函数不是 Object 的属性，函数原型属性的原型指向 Object 的原型属性
  Array.prototype 的原型是 Object.prototype，数组不是 Object 的属性，数组原型属性的原型指向 Object 的原型属性

- Object.create（新创建对象的原型对象） 即为新创建的对象指定一个原型对象
  person2 = Object.create(person1) 为 person2 设置原型 person1
  Object.getPrototypeOf(person2,person1) 为 person2 设置原型 person1

- js 中有可枚举属性和不可枚举属性的区分，不可枚举属性不可以通过 for/in 循环访问
  in 运算符判断对象及其原型中是否有对应的可枚举属性，for/in 循环也可以访问到原型中的可枚举属性
  hasOwnProperty() 方法只访问自身的属性，不访问原型； map. hasOwnProperty("toString")
- Object.defineProperty() 为对象添加有特殊性质的属性；定义是否可被枚举属性，可被写，可被重新设置等等；
  Object.defineProperty(obj ,"asd" ,{ get: function(){return this.a\*this.b} , set: function(val){console.log(val)}})

- get 和 set 方法

  - 在对象中指定属性的读取函数和修改函数，属性在读取和修改时会分别调用 get 和 set
  - 使用方法 obj = {a:1 ,b:2, get asd(){return this.a\*this.b},set asds(val){console.log(val)} set 不能有返回值
  - 调用方法 obj.asd，get 有返回值 ； obj.asds=123123 set 一定要赋值
  - 都可以通过 Object.defineProperty() 添加到对象中
    Object.defineProperty(obj ,"asd" ,{ get: function(){return this.a\*this.b} , set: function(val){console.log(val)}})

- 面向对象的含义

  - 封装：把表达一个事物的信息及对其可能进行的操作（即函数）放在一起。
    放在一起最终形成
    // class 描述一类事物
    // object 描述某一类物事的具体个体

    同一类对象都有相同的一组属性和一组函数

  - 继承：让一个类直接获取另一类的所有属性和方法（重用已经写好的代码）

  - 多态：不关心得到的事物具体是什么类别，更这个事物是否有某方面的特性（有特定的一组属性和方法）
    例如对象，数组等都有 toString 方法，我们可以不关心调用这个方法的类型和调用结果，大家都可以用 toString 这个接口调用到自己想要的结果

## 正则表达式 (Reg)

- 目的：作字符串的模式匹配
- 一种领域特定语言（DSL/Domain specific language）, 可以在多种语言和工具中使用，是一种对象
- 创建方法
  - var reg1 = new RegExp("abc"，"ig") 构造函数
  - var reg2 = /abc/ig 直接量 / 字面量
  - re1 = /foo\nbar/ 字符串的语法（\n;\t）在正则表达式字面量里面不生效 /foo\nbar/
    re2 = new RegExp("foo\\nbar") 构造函数里面有回车功能，所以需要加、转义 /foo\nbar/
  - 如果正则表达式里面有自己的特殊符号语法时（如 + \* ？等等），需要转义
- new RegRxp("") => /(?:)/ 特例，不匹配任何内容
  /(?:)/.exec("asd") =>["", index: 0, input: "asd", groups: undefined]

- 相关方法

  - test /ab\d/.test("ab5sd")=>true 判断正则表达式和字符串是否匹配
  - exec /\d+/.exec("one two 100")=> ["100", index: 8, input: "one two 100", groups: undefined] 无法匹配返回 null，否则返回一个表达字符串信息的对象

- 相关属性

  - source 表示正则表达式的源代码 /asdf/.source=>"asdf"
  - lastIndex 表示正则表达式下一次匹配的起始位置，默认为 0，只有启用了全局 g 才可以使用；
    匹配成功后把 lastIndex 的值变为匹配位置（index）的后一个位置，下一次匹配从 lastIndex 位置开始；匹配失败变为 0；
    由于 lastIndex 的该特性，在全局模式下 text,exec,replace 方法的匹配位置都会受到影响，要小心使用
  - dotAll 表示。号是否代表所有的符号
  - ignoreCase 忽略大小写，缩写为 i
  - sticky 要求每一次匹配必须从上一次匹配结束之后的位置（lastIndex）开始匹配（缩写为 y ）
  - multiline 表示可换行，缩写为 m
  - unicode 表示通过 16 进制 unicode 编码匹配，缩写 u
  - flags: 表示 i,g，m,y.u 等这些属性集合

- 匹配字符集 []
  \d : [0-9] \D：前者取反
  \w:[0=9a-zA-Z\_] 数字字母加上一个下划线 \W：前者取反
  \s : 任意空白的字符 \S: 前者取反
  . : 除了换行符以外的任意符号
  [^] : 可以取 ��� 所有的符号，包括换行符；^ 在这里是取反的意思

  - [] 里面的特殊字符都没有特殊含义，仅仅代表一个普通字符 [+ \* . ? 等等】
  - [] 开头可以加一个脱字符 ^ /[^01]/ 表示非 0 和非 1 ； /^01/ 表示字符串的起始位置为 0；

- 相关规则
- 重复
  只对前面紧挨着的一个字符或者一个组生效

  - "+"号，出现多次
  - "\*" 号 出现任意次数
  - "?" 出现 0 次或者 1 次
  - {n} 出现 n 次 {2,4} 2 到 4 次 ； {4,}4 次及以上

    - 贪婪匹配
      由于正则表达式的回溯机制，每个正则符号都会首先尝试匹配最多的内容然后再回头，这种模式就是贪婪匹配
    - 非贪婪匹配
      和贪婪匹配相反，每个正则符号尽可能匹配少的内容，只有在剩余部分没办法完成匹配时才会匹配更多的内容
      表示方法： 在重复操作符后面加上？即变为非贪婪匹配（+?;\*?;??;{}?;）
    - 匹配 unicode 码对应的字符（开启 16 进制 unicode 模式配合、u 使用）
      /\u{6211}/u.test("我")=>true
      /[\u{6211}-\u{7411}]/u.test("是")=>true

- 分组

  - 使用（）号，里面的内容会当作一个整体，（）里面匹配到内容单独添加到相关方法的返回值里的行为叫做捕获，也叫捕获分组

  - 非捕获分组：在（）内部前面加上？： 即变为 (?:), 非捕获分组的内容会当作一个整体，但是（）里面匹配到的内容不会添加到相关方法的返回值里

  - 为分组取名：(?<name>) 在括号前面加上一个？号和尖括号，名字写在尖括号里面，命名的分组信息会出现在返回值的 group 属性里面；（在旧的浏览器无法使用）
    /(?<year>\w\d)/.exec("adasd2313")=>["d2", "d2", index: 4, input: "adasd2313", groups: {…}]
    /(?<year>\w\d)/.exec("adasd2313").groups =>{year: "d2"}

  - 分组的后向引用
    "韩朵朵 李依依".match(/.(.)\1/g)=>["韩朵朵", "李依依"]
    "ABBA ABBB".match(/(.)(.)\2\1/g)=>["ABBA"]
    正则表达式里面的、n 代表的是对第 n 个分组的重复引用 （1<=n<=9）

- 匹配

  - 使用分组匹配到的内容也会出现到数组中
    /foo(bar)(bas)baz/.exec("foobarbasbazaaa")=>["foobarbasbaz", "bar", "bas", index: 0,input: "foobarbasbazaaa", groups: undefined]
  - 如果分组没有匹配到字符串，在数组对应的元素是 undefined
    /foo(bar\d)?baz/.exec("foobaz")=> ["foobaz", undefined, index: 0, input: "foobaz", groups: undefined]
  - 如果分组匹配到了多个元素，那么数组中只有最后一个匹配项
    /foo(bar\d)+baz/.exec("foobar1bar2bar3baz")=>["foobar1bar2bar3baz", "bar3", index: 0, input: "foobar1bar2bar3baz", groups: undefined]

- 零宽断言
  零宽断言：匹配两个符号之间的一个位置而不是一个符号（宽度为零）
  匹配发生时，光标不会移动，所以可以对同一个位置执行多个零宽断言匹配，只有当每个断言都成功时才可以
  有 4 种零断言：
  (?=expr) 正预测零宽断言，这个位置的右边满足 expr /er(?=ads)/.exec("aqqweradssd")=>["er", index: 4, input: "aqqweradssd", groups: undefined](?!expr) 负预测零宽断言，这个位置的右边不满足 expr /(?!f..)aa/.exec("aafafffffax")=>["aa", index: 0, input: "aafafffffax", groups: undefined](?<=expr) 正回顾零宽断言，这个位置的左边满足 expr（旧版 JS 不支持）
  (?<!expr) 负回顾零宽断言，这个位置的左边不满足 expr（旧版 JS 不支持）

  \*单词和字符串边界
  ^ === /(?<![^])/ 字符串的开头 左边不出现任何字符
  $ === /(?![^])/ 字符串的结尾 右边不出现任何字符
  \b === /(?<=\w)(?=\W)|(?<=\W)(?=\w)|(?<![^])|(?![^])/ 左边是字符右边不是 或者 左边不是字符右边是 或者 字符串开头 或者 字符串结尾
  单词边界是字符串的开始或者结束位置，也可以是任意单词（/w）和任意非单词字符（/W）之间的位置
  下面。号左右两边都是单词边界，因为"."是、W, 而其左右两边都是、w, 他们中间就是单词边界
  "bar.baz".match(/\b\.\b/)=>[".", index: 3, input: "bar.baz", groups: undefined]

  - 字符串和正则表达式相关的方法
    -match, 不考虑正则表达式的 lastIndex 属性。
    当正则表达式有 g 标志的时候，匹配出所有能够满足整条正则表达式的内容，不会把分组捕获到的内容也放入结果数组
    当没 g 标志的时候，匹配出第一条能满足的内容，同时把分组捕获到的内容也放入结果数组

    - replace(RegExp|String, String|Function)
      两个参数都是字符串：匹配第一次出现的内容为目标内容，不会修改原字符串
      首参为正则
      次参为字符串，里面的 $&,$1,$2~$9 是特殊内容，表示匹配到匹配到的内容以及各个分组捕获到的内容
      次参为函数，把整个匹配到的内容以及各分组捕获到的内容传给函数做为参数，把函数返回值插入被替换位置，有多少次匹配，函数就会调用多少次

    -re.exec(str) 方法
    如果 re 不带 g 标志，则完全等同于 str.match(re)
    如果 re 带有 g 标志，则从 str 的 re.lastIndex 位置开始查找，查找成功后把 re.lastIndex 置为匹配位置的后一个位置
    查找不成功的时候，返回 null，把 lastIndex 置为 0

    -str.split(String|RegExp)
    当参数是字符串时，按字符串把原字符串拆成数组
    当参数为正则时，按正则把原字符串拆成各部分的数组，但是
    当正则里有捕获分组时，分组捕获到的内容也会出现在结果数组的相应位置

  - https://regex101.com/ debug 正则表达式网站
    https://regexper.com/ 查看正则表达式流程图

## Date

- i18n internationalization 国际化
  i10n localization 本地化
- JS 中月份从 0 开始，日期是从 1 开始（坑）
- 时间戳 1970 年距离现在多少毫秒；1970 前的时间用负数表示 d.getTime() 获取到现在的毫秒时间
- Date.now() 当前时间戳
- moment.js https://momentjs.com/
  最常用的日期库

## DOM Document Object Model

## 事件

     *elements.click()  触发 click 事件，可以触发除默认交互之外的交互行为
     * elements.dblclick()  触发双击事件前会触发两次单击事件
     *Event.which 表示哪一个鼠标按钮被按下，
      0 表示无，1 表示左键，2 表示中键，3 表示右键；
      无法表示组合鼠标键，此属性总是只展示最先按下去的键
     *Event.buttons 表示哪些鼠标按钮被按下，
      它的二进制形式的最低位表示左键 (001)，第二位表示右键 (010)，第三位表示中键 (100)
      所以同时按下中键和右键将会得到 6，依此类推 (100 | 010 = 110)

- 滚动事件（scroll)
  Element.scrollHeight: 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容
  Element.scrollTop 属性可以获取或设置一个元素的顶部到视口可见内容（的顶部）的距离；当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为 0。
  Window.scrollTo 滚动到文档中的某个坐标。
  Element.scrollBy(x,y) 设置元素里面的滚动水平垂直移动的 px
  滚动事件"scroll"的 preventDefault 无法阻止滚动，因为该事件处理器是在滚动之后才触发的， mouseWheel/DOMMouseScroll 这两个也是滚动事件，可以设置 passive: false 阻止滚动
  window.addEventListener('mousewheel/touchmove', f, {
  passive: true// 告诉浏览器将不会在事件处理函数中调用 preventDefault，浏览器可以事件处理函数运行的同时，就开始执行默认事件（最典型的情况即为滚动页面），使滚动更流畅（浏览器少数可以边解析边渲染的地方）
  })
- 长度相关
  - element.offsetWidth/element.offsetHeight 元素空间大小 包含边框
  - element.clientWidth/element.clientHeight 元素空间大小 不包含边框
  - element.getBoundingClientRect 返回一个对象，表示元素 4 个方位到视口左上角垂直距离
  - element.getClientRect 用于分行的元素，每行都有一个结果，返回数组
  - innerHeight 窗口高度
  - document.body.scrollHeight 整个页面高度
  - pageYOffset/scrollY 当前滚动位置
  - Event.clientX/clientY 鼠标相对于视口的位置
  - Event.pageX/pageY 鼠标相对于文档的位置
- 焦点事件
  - focus/blur 不会冒泡
    focusin/focusout 会冒泡
    window.onfocus/blur 窗口也有焦点事件
    elements.foucs() 使元素获得焦点
- 加载事件

  - window.onload 是在页面所有资源加载完成时触发，包括 css, 图片，脚本等等；常用于页面构建完成时使用 load 进行初始化
  - 浏览器遇到<script>标签会立即执行，之后再执行下面的代码；因为 js 代码里面可能会有 DOM 操作，这样不同的执行时刻页面有不同的显示，所以浏览器都是立即执行
    所以大型网站一般都把<script>标签放到后面；
    <script async src =""> <script defer src = "">为有 src 属性的 script 加上 async 或者 defer 属性会使 script 在页面加载完成之后执行
    CSS 代码写在前面，这样遇到标签就可以渲染其样式
  - load 事件是在所有外部资源加载完成时触发，而 DOMContentLoaded 是在 DOM 解析完就触发，所以我们现在都用更快的 DOMContentLoaded
    beforeunload 事件，关闭页面或者跳转链接时触发
  - readystatechange 事件 当文档的 readyState 属性发生改变，readystatechange 事件会被触发。
    document.readyState === "complete" 表示 DOM 解析完，可以替代 DOMContentLoaded。兼容性更好
  - 脚本执行时间线
    - 很多事件都会触发脚本（程序）执行，同一文档中无法同时执行 2 个脚本（CSS3 动画除外，其可以继续持续执行）
    - js 是单线程语言，但可以使用 Worker 函数将耗时的操作放到后台运行，其可以独立文档主程序运行；
      worker 之间不能共享数据，只能通过事件"message"与 postMessage 来发送消息，所发送的消息是复制之后发送过去的，所有修改接收到的消息是不会改变源消息的；
      worker 内不能访问 dom, 以及任何与 UI 相关的接口
  - 时间定时器
    - setTimeout 设置函数多少毫秒后调用 其返回值是一个任务号数字
      clearTimeout（number） 清除该任务，不在调用队列里
      var number = setTimeout(fun,time)
    - setTimeout 最快也要将其调用栈里面的代码执行完毕之后再调用函数，即使时间设置为 0；
    - setInterval/clearInterval 设置函数每隔多少毫秒调用
  - 事件防抖（降低事件多次连续迅速触发，如 mousemove，scroll)

    - debounce 防抖函数
      function debounce(f,time){
      let timeId = null
      return function(...argments){
      clearTimeout(timeId)
      var timeId=setTimeout(f(argments),time)
      }
      }
      只有在连续时间内，不在触发频繁事件后的 time 秒后，执行真正的回调，如输入联想
    - throttle 节流函数
      function throttle(f, duration) {
      var timerId
      var lastRunTime = 0
      return function(...args) {
      clearTimeout(timerId)
      var now = Date.now()
      if (now - lastRunTime > duration) {
      f(...args)
      lastRunTime = now
      } else {
      timerId = setTimeout(() => {
      f(...args)
      lastRunTime = Date.now()
      }, duration)
      }
      }
      }
      以一定的频率触发，降频；如鼠标滚动
      理解上述函数注意 setTimeout 里面的函数调用时修改局部变量影响其他事件是否触发

    * 创建自定义事件
      Events 可以使用 Event 构造函数创建如下
      var event = new Event('build');
      elem.addEventListener('build', function (e) { ... }, false);
      elem.dispatchEvent(event) （触发改事件）

## swiper

- 轮播图库
  https://idangero.us/swiper/demos/

## base64

- 64 进制编码
  0 —— 9 10
  a —— Z 52
  - / 2
- 早期电子邮件附件的编码传递
- data uri 将数据 64 位编码
- 全字母解码 （atob）
  全字母编码 （btoa）
  \*DataURL 把数据直接编码进了 url 里面。可以通过 base64，也可以直接把数据的原始文本直接放进 url 中

# 计算机网络

## 计算机网络的基础知识

- ip 地址的分类
  \*IP 地址是按照地区划分
  - A 类地址第 1 字节为网络号，其它 3 个字节为主机号。 A 类地址的网络号第一位固定为 0，网络号只有 7 位可以使用，可以指派的网络号是 2^7-2 = 126 个。
    B 类地址的前两个字节为网络号，后两个字节为主机号。
    C 类地址的前三个字节为网络号，最后一个字节为主机号
- 带宽：单位时间内通过网络的数据量
  延迟：传播需要的时间
- 常用协议端口号
  http:80
  DHCP:67
  DNS: 53
  FTP：21
  NTP: 123 Network Time Protocol 网络时间协议，用于时间同步，基于 UDP 协议
- 域名：域名就是为 IP 地址起的名字；IP 地址不好记，可以用域名代表 IP 地址
- VPN Virtual Private Network
  - VPN 相当于给每个内部设备配置了一个虚拟网卡，用与内部设备的通信
  - 每个内部设备可以连接总部的 VPN 服务器，通过服务器获取接收数据
  - 加密性高
- IPv6
  - 128bite 长度，是 ipv4 的 4 倍，可以有 2\*\*128 个 ip 地址
    升级推广难，少数几构使用，目前用 NAT 路由器这种方式
    现在的推广的方式是在 IPv6 地址传播过程中把其包裹在 ipv4 的数据里，只在起始和结束位置将 ipv6 解析出来
- 基于 UDP 的协议：dhcp/dns/ntp 低延迟
  基于 TCP 的协议：http/ftp/tls/ws/socks5 可靠性高
- socks 协议
  SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递；当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。
- PAC 代理自动配置 proxy auto-config
  控制网络流量是否走代理服务器
- 加密算法的类型 \*对称加密

  - 加密和解码用到是同一个密码 \*非对称加密（RSA）
  - 加密和解码用的是不同密码
    密钥是一对（公钥加密，私钥解密；私钥加密，共用解密）

- URL(Uniform Resource Locator)
  HASH:URL 的位置标识符，跟在＃符号后面的 URL 部分，包括＃符号
  - 是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP 请求中不包括#
  - 改变#不触发网页重载发送请求
  - onhashchange 事件
  - 改变#会改变浏览器的访问历史
    ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
    │ href │
    ├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
    │ protocol │ │ auth │ host │ path │ hash │
    │ │ │ ├─────────────────┬──────┼──────────┬────────────────┤ │
    │ │ │ │ hostname │ port │ pathname │ search │ │
    │ │ │ │ │ │ ├─┬──────────────┤ │
    │ │ │ │ │ │ │ │ query │ │
    " https: // user : pass @ sub.example.com : 8080 /p/a/t/h ? query=string #hash "
    │ │ │ │ │ hostname │ port │ │ │ │
    │ │ │ │ ├─────────────────┴──────┤ │ │ │
    │ protocol │ │ username │ password │ host │ │ │ │
    ├──────────┴──┼──────────┴──────────┼────────────────────────┤ │ │ │
    │ origin │ │ origin │ pathname │ search │ hash │
    ├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
    │ href │
    └────────────────────────────────────────────────────────────────────────────────────────────────┘
- XSS 跨域整个站点的脚步攻击 Cross Site Scripting
  永远不要把用户输入的东西当做代码执行，可以通过转义客户文本执行
  CSRF 跨站请求伪造 cross site request forgery
  - 浏览器会自动发送其它页面的 cookie 到对应服务器（历史遗留问题）
    现在该问题已经解决，浏览器现在默认不会对跨域请求发送 cookie
  - 通过 referer 头验证请求来源
  - 添加校验 token
  - 通过 js 发送请求，有跨域限制

## HTTP

- 抽象请求

* Ajax
  - Asynchronous JavaScript + XML（异步 JavaScript 和 XML）用来描述一种使用现有技术集合的‘新’方法；JavaScript 执行异步网络请求
  - Axios 是一个基于 promise 的 HTTP 库 ，里面封装了 Ajax 相关功能，可以直接发送 get,post 等请求；支持 promise 和 async/await
    http://www.axios-js.com/docs/ npm install axios
    - 创造一个 axios 实例，实例上配置一些共用的属性，api = axios.create({baseURL:"url 共用前缀地址"，withCredentials:true,解决跨域和 cookie 的冲突})
      export default api
    - axios.get('/user?ID=12345').then()
      axios.get('/user', {params: {ID: 12345}}).then()
      get 请求的 query 信息可以写在第二个参数里，可以通过 req.query.ID 拿到数据
    - 某个请求的响应包含以下信息
      {
      // `data` 由服务器根据你的请求提供的响应
      data: {},
      // `status` 来自服务器响应的 HTTP 状态码
      status: 200,
      // `statusText` 来自服务器响应的 HTTP 状态信息
      statusText: 'OK',
      // `headers` 服务器响应的头
      headers: {},
      // `config` 是为请求提供的配置信息
      config: {}
      }

- 跨域问题

  - CORS

    - CORS 与 cookie

      - 一个网站只能读取到自己网站服务器的 cookie，cookie 信息按照服务器地址分组储存在浏览器里
      - 一个网站向不是自己的服务器 B 发送请求时，会自动带上服务器 B 的 cookie；
      - 但是在 CORS 中跨域发送请求时默认不带上服务器 B 的 cookie，而且第一次登陆后接收到的 cookie 也不会储存在浏览器
      - 为了解决上面的问题，需要在发送请求时带上 withCredentials：true 这个请求头
      - 如果使用了 Access-Control-Allow-Origin:\* ，就不能使用 cookie, 可以改为指定地址
      - express 框架里面可以通过 app.use(cors({})) 中间键配置解决这个冲突,该中间件需要 npm cors
        app.use(cors({
        origin:true, 相当于 Access-Control-Allow-Origin:\*
        maxAge:86400,
        credentials:true,
        }))

    - JSONP 一种跨域方案
      通过 script 等标签进行跨域，把请求的数据作为一个函数的参数，引进之后调用函数操作数据；
      给路径传递参数 get 想要的资源
      function jsonp(url, data) {
      return new Promise((resolve, reject) => {
      var script = document.createElement('script')
      var callbackName = 'JSONP*CALLBACK*' + Date.now() + Math.random().toString(16).slice(2)

            url = url + '?' + [...Object.entries(data)].map(pair => {
              return pair.join('=')
            }).join('&') + '&callback=' + callbackName

            window[callbackName] = function(data) {
              delete window[callbackName]
              document.head.removeChild(script)
              resolve(data)
            }

            script.src = url

            script.onerror = function(e) {
              delete window[callbackName]
              document.head.removeChild(script)
              reject(e)
            }

            document.head.appendChild(script)
          })

      }
      拦截方法：将自带 api 换为自己包装的

    - 服务器代理 服务器之间的通信没有跨域问题

      - API 代理跨域
        一个网站向不是自己的服务器 B 发送请求时，自己的服务器直接从目标服务器请求信息，把收到的信息发回浏览器，这个是反向代理；
        需要在 package.json 文件夹里面加上"proxy":目标 url; 自己的服务器就可以代理这个 url 目标服务器
      - 正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；
        而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见

    - Google 浏览器的跨域配置
      属性-快捷方式-目标 chrome.exe --disable-web-security --user-data-dir="c:\a\b"

- 运用 HTTP 实现客户端和服务器的通信
  *RPC remote procedure calls 远程过程调用
  http 的协议是通信工具，传递一些参数给服务器，函数在服务器执行
  *RESTful
  通过相关方法操作服务器资源（post/delete/put/get 增删改查）
