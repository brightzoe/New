<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>abc {</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <p><strong>为啥用css:</strong>
HTML可以控制的样式太少
样式不能跨页面复用，跟上一条类似
各种度量单位不能选，只能以像素和百分比为单位
无法灵活实现布局 可维护性很差</p>
<p><strong>CSS Cascading Style Sheet 层叠样式表</strong>
选择器:
声明与关键词
声明中的属性和属性中的值必须是css及对应属性所支持的,否则无效
颜色属性会继承</p>
<pre><code class="language-css"><div><span class="hljs-comment">/*元素选择器*/</span>
<span class="hljs-selector-tag">div</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-comment">/* 选择器分组 */</span>
<span class="hljs-selector-tag">p</span>,
<span class="hljs-selector-tag">h1</span>,
<span class="hljs-selector-tag">div</span> {
  <span class="hljs-attribute">color</span>: red;
}

* {
  <span class="hljs-attribute">color</span>: red;
}



<span class="hljs-comment">/*类选择器*/</span>
<span class="hljs-comment">/* &lt;p class="foo abc ddd"&gt;&lt;/p&gt; */</span>
<span class="hljs-selector-class">.foo</span> {
  <span class="hljs-attribute">color</span>: red;
}


<span class="hljs-comment">/*id选择器,一个元素只有一个id*/</span>
<span class="hljs-comment">/* &lt;h1 class="" id="abc"&gt;&lt;/h1&gt; */</span>
<span class="hljs-selector-id">#abc</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-comment">/* 选择器名大小写敏感 */</span>

<span class="hljs-comment">/*属性选择器*/</span>
<span class="hljs-selector-attr">[title]</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-selector-attr">[title="hello"]</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-comment">/* 属性以指定内容开头 */</span>
<span class="hljs-selector-attr">[title^='woo']</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-comment">/* 属性以指定内容结束 */</span>
<span class="hljs-selector-attr">[title$='ooo']</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-comment">/* 属性包含指定元素 */</span>
<span class="hljs-selector-attr">[title*='ooq']</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-comment">/* 包含一个完整单词 */</span>
<span class="hljs-selector-attr">[title~="our"]</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-comment">/* 以下相同 */</span>
<span class="hljs-selector-attr">[class~='bar']</span> {}

<span class="hljs-selector-class">.bar</span> {}


<span class="hljs-comment">/* 类名以特定内容开头 */</span>
<span class="hljs-selector-attr">[class^="fa-"]</span>,
<span class="hljs-selector-attr">[class*=" fa-"]</span> {
  <span class="hljs-attribute">text-decoration</span>: underline;
}

<span class="hljs-comment">/* 类名以特定内容结尾 */</span>
<span class="hljs-selector-attr">[class$="-ui"]</span>,
<span class="hljs-selector-attr">[class*="-ui "]</span> {
  <span class="hljs-attribute">text-decoration</span>: line-through;
}

<span class="hljs-comment">/* 属性前缀选择器(选择lang为zh 或以zh开头的元素) */</span>
<span class="hljs-selector-attr">[lang|="zh"]</span> {}


<span class="hljs-comment">/* 忽略大小写,后面加个i, ignore */</span>
<span class="hljs-selector-attr">[href$=".pdf"i]</span> {}

<span class="hljs-comment">/* 复合选择器 */</span>
<span class="hljs-comment">/* &lt;p class="class1 class2 lsdkfj lksdfj" id="abc"&gt;&lt;/p&gt; */</span>
<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.class1</span><span class="hljs-selector-class">.class2</span> {}

<span class="hljs-selector-class">.class1</span> <span class="hljs-selector-class">.class2</span> <span class="hljs-selector-id">#abc</span> {}


<span class="hljs-comment">/* 子元素选择器:选择子元素,但里面的元素会继承 */</span>
<span class="hljs-selector-tag">a</span>&gt;<span class="hljs-selector-tag">span</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid;
}

<span class="hljs-comment">/* 选择a里面的所有span元素 */</span>
<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">span</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;
}

<span class="hljs-comment">/* a里面的span的里面的span */</span>
<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">span</span> <span class="hljs-selector-tag">span</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;
}

<span class="hljs-comment">/* 邻接选择器;只能向后选*/</span>
<span class="hljs-comment">/* 同级,相邻的一个p */</span>
<span class="hljs-selector-tag">h1</span>+<span class="hljs-selector-tag">p</span> {}

<span class="hljs-comment">/* 后面的所有p */</span>
<span class="hljs-selector-tag">h1</span>~<span class="hljs-selector-tag">p</span> {}

<span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">ul</span>&gt;<span class="hljs-selector-tag">li</span>~<span class="hljs-selector-tag">li</span> {}

<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.c</span> {
  同时有a,
  b,
  c类名的元素
}

<span class="hljs-selector-class">.a</span> <span class="hljs-selector-class">.b</span> <span class="hljs-selector-class">.c</span> {
  类名为a的元素里面的类名为b的元素里面的类名为c的元素
}

<span class="hljs-selector-class">.a</span>,
<span class="hljs-selector-class">.b</span>,
<span class="hljs-selector-class">.c</span> {
  类名为a或b或c的元素
}

<span class="hljs-comment">/* 伪类选择器 */</span>
<span class="hljs-comment">/* 状态伪类 */</span>
<span class="hljs-selector-pseudo">:link</span> {
  未被访问过的有href属性的a标签
}

<span class="hljs-selector-pseudo">:visited</span> {
  访问过的标签;
  只能设置颜色,
  隐私安全原因
}

<span class="hljs-selector-pseudo">:active</span> {
  被激活的元素,
  鼠标按下的
}

<span class="hljs-selector-pseudo">:hover</span> {
  鼠标放上去的元素
}

<span class="hljs-comment">/* 书写顺序:LV HA */</span>

<span class="hljs-selector-pseudo">:focus</span> {
  光标放上去,
  被聚焦的元素
}

<span class="hljs-selector-pseudo">:first-child</span> {
  匹配所有某父元素的第一个子元素
}

<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span> {
  选择作为第一个子节点的p元素,
  而不是p的第一个子节点
}

<span class="hljs-selector-pseudo">:last-child</span> {}

<span class="hljs-selector-pseudo">:nth-child(2n+1)</span> {
  选中第奇数个元素,
  可以设置一些规则
}

<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(n+3)</span><span class="hljs-selector-pseudo">:nth-last-child(n+2)</span> {
  ul里面的li且正数第三个到倒数第二个 加了空格就是里面的,
  注意空格
}

<span class="hljs-selector-pseudo">:nth-child(odd</span>/<span class="hljs-selector-tag">even</span>) {
  选择奇偶数
}

<span class="hljs-comment">/* 选择器取反 */</span>
<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-pseudo">:not(p)</span> {
  ul里面不是p的元素
}

<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-pseudo">:not(.foo)</span> {
  里面只能用单个选择器,
  不能用层级
}

<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-pseudo">:not(p)</span><span class="hljs-selector-pseudo">:not(.foo)</span> {
  可以用多个: not()组成复合选择器
}

<span class="hljs-selector-pseudo">:root</span> {
  选择文件的根元素
}

<span class="hljs-selector-pseudo">:empty</span> {
  选择空元素,
  包括自闭合标签
}

<span class="hljs-selector-pseudo">:target</span> {
  选中当前id值为#后面的元素的内容;
  也就是目标元素的内容
}

<span class="hljs-selector-pseudo">:required</span> {}

<span class="hljs-selector-pseudo">:optional</span> {}

<span class="hljs-selector-pseudo">:valid</span> {}

<span class="hljs-selector-pseudo">:invalid</span> {}

&lt;<span class="hljs-selector-tag">input</span>&gt;<span class="hljs-selector-pseudo">:enabled</span> {}

<span class="hljs-selector-pseudo">:disabled</span> {}

<span class="hljs-selector-pseudo">:checked</span> {}

<span class="hljs-comment">/* 选择器的优先级 */</span>
<span class="hljs-comment">/* 0,1,1,1 */</span>
<span class="hljs-comment">/* (0,id选择器,类选择器/属性选择器/伪类选择器,元素选择器) */</span>
<span class="hljs-comment">/* 连接符如 &gt; + ~ 等不参与优先级的计算 */</span>

<span class="hljs-comment">/* 内联样式/行内样式/行间样式/inline style  */</span>
<span class="hljs-comment">/* 1，0，0，0  */</span>
&lt;<span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">style</span>="<span class="hljs-selector-tag">color</span>: <span class="hljs-selector-tag">green</span>;"&gt;

<span class="hljs-comment">/* 最优先: !important  */</span>
<span class="hljs-selector-tag">p</span> {
  <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;
}

<span class="hljs-comment">/* 0.0.0.0 */</span>
* * * {
  通配符
}
</div></code></pre>
<p>继承:没有优先级，比【*】的有限级还要小</p>
<p>不来自CSS的样式: 如font标签
<font size color face></font>
可以想象它的优先级为0000,并且出现在作者样式的开头</p>
<ul>
<li><em>层叠样式(优先级从高到低:)</em>*</li>
<li>用户自定义important样式</li>
<li>网站作者important样式 authored style</li>
<li>网站作者作者普通样式</li>
<li>用户自定义普通样式 Custom.css</li>
<li>默认样式，浏览器内置样式，User Agent Style</li>
<li>优先级一样的话，按出现的顺序排列，后出现的优先级更高
<ul>
<li>所以是 link visited focus hover active</li>
<li>:link:hover /0 0 2 0/</li>
<li>不过在这几个伪类上分别写完全不同的属性时，顺序就不重要了</li>
<li>重要的是写相同的属性，这时就要考虑优先级的问题了</li>
<li>LV HA VL HA 没有太大区别，因为很明显，V和L不会同时匹配</li>
<li>不来自CSS的样式
<ul>
<li>如font标签 <font size color face></font></li>
<li>可以想象它的优先级为0000并且出现在作者样式的开头</li>
<li>会被作者样式和读者样式覆盖，但不会被默认样式覆盖</li>
<li>p75页</li>
</ul>
<pre><code><code><div></div></code></code></pre>
</li>
</ul>
<font color="red">aa</font> <style> {
  color: green;
}
</style>
<pre><code><code><div>
</div></code></code></pre>
</li>
</ul>
<p>:nth-of-type(2) {}
/* 给类型分类,匹配所有类型的第二个 */</p>
<p><strong>值与单位</strong>
数字:
line-height:2    200%,倍数
column-count: 2;
zoom: 2.5;</p>
<p>百分比:
width/height: 60%;    基准是其父元素的宽度或高度
top/left/right/bottom: 50%;
line-height: 150%;    基准是文字的大小
vertical-align: 40%;
color: rgb(40%, 50%, 70%)</p>
<p>颜色: R G B
color:red/silver/grey;</p>
<p>#(0-255)(0-255)(0-255) -&gt;16700000    hex color
#abc -&gt;#aabbcc
#abcd - #aabbccdd
#456 -&gt;#445566
#XYZ -&gt;#XXYYZZ
#XYZA -&gt;#XXYYZZAA</p>
<p>rgb(0-255,0-255,0-255);
rgb(30%,30%,30%)相对于255来说
rgba(r,g,b,0-1);</p>
<p>色域</p>
<p>色彩空间
RGB
CMYK (Cany Manganta Yellow BlacK)
hsla（色相，饱和度，明度,0-1）</p>
<p>长度
绝对长度: in(ch) cm mm
相对长度:
px,CSS像素,在设计中大多数被认为是绝对长度</p>
<pre><code>em: 基准是当前元素字号的大小,当前没有的话就继承父元素
1 em=100%
rem,基准是html元素字号,做到灵活缩放整个网页
vw/vh,视觉窗口的宽度/长度
  1vw 视口宽度1/100
  vmax=max(vw, vh)视口宽或者高较大的那一个的100之一
  vmin=min(vw, vh)视口宽或者高较小的那一个的100之一

width: calc(2 * 30em - 40%)
</code></pre>
<p>角度
degree 45deg 90deg
radian 弧度  3.14rad=180deg</p>
<p>时间 s ms</p>
<p>URL background-image: url(a.png);指定背景图片/字体
相对路径 绝对路径</p>
<p><strong>字体</strong></p>
<ul>
<li>字体族
<ul>
<li>serif 衬线字体,不等宽</li>
<li>sans-serif 非衬线字体,成比例</li>
<li>monospace 字体，等宽字体</li>
</ul>
</li>
</ul>
<p>字体名中间有空格、尾部有# $等符号，建议使用引号</p>
<ul>
<li>
<p>另外，通用字体族必须不能加引号，它们算是关键字而不是字体值（字符串）</p>
</li>
<li>
<p>但是，有时候用户的浏览器并不一定安装了这个字体</p>
</li>
<li>
<p>这时可以指定退化（fallback）方案
h1 {
font-family: &quot;Helvetica&quot;, &quot;微软雅黑&quot;, sans-serif;
}</p>
</li>
<li>
<p>一般来说，最好提供一个字体族名称做为最后的退化方案</p>
</li>
</ul>
<p>字重 font-weight  100-900
normal=400
bold=700
bolder lighter</p>
<p>字号 font-size
绝对尺寸：
xx-small,
x-small,
small,
medium,
large,
x-large,
and xx-large</p>
<p>百分比大小:
一般是相对于父元素的大小，也即继承过来的值;旦line-height相对于元素的font-size</p>
<p>font-size继承是继承父级的计算值,而不是百分比</p>
<p>font-style
normal italic oblique</p>
<p>font-variant
normal  small-caps:小型的大写字母
text-transform：uppercase/captialize
+把小写字母显示成小号的大写字母
+有些字体专门为小写字母设计了这种样式，而不是单纯的把大写字母显示的小一点。</p>
<pre><code>- font:
[font-style || font-variant || font-weight] font-size[ / line-height] font-family
- font: small-caps bold 20px / 1.2em 宋体,serif;
- 前三个的顺序不重要
font属性值的覆盖，整个是一个属性，值会一起背新值覆盖
</code></pre>
<p>使用系统字体:(只能整体设置)
caption:用于有标题的控件,如按钮.
icon:用于对图标加标签.
menu:用于菜单,及下拉菜单和菜单列表.
message-box:用于对话框.
small-caption:用于小空间加标签.
status-bar:用于窗口状态条.
例:button {font:caption;}</p>
<p>text-indent 文字缩进[用于块级元素],用负值可以隐藏文字</p>
<p>text-align 文字水平对齐
left,right,center,justify</p>
<p>line-height</p>
<p>vertical-align:(行内元素/替换元素垂直对齐)
sub/supper 上标元素/下标元素
baseline/bottom/top</p>
<p>word-spacing:其值是添加到本身空格间的值，而不是设置了多少，单词间就间隔多少</p>
<p>Text Decoration
none | [ underline ‖ overline ‖ line-through ‖ blink]
可联合使用: h2 {
text-decoration: underline overline;
}
元素非继承，但子元素无法使用 none 清除父元素的 underline 等，决定于用户代理
text-transform: uppercase/lowercase/capitalize/
Text Shadows
none | [<length>‖<length><length>?] color
两个 length，表示水平和垂直偏移，第三个可省略:模糊半径：从阴影外边缘到模糊范围边缘，具体的模糊方法由用户代理决定
每组中间,分隔
text-shadow:
1px 1px #2d343a,
2px 2px #2d343a,
3px 3px #2d343a;
特大范围阴影可能造成性能问题</p>
<p>box-shadow 与上类似
- 水平偏移 垂直偏移 模糊半径 扩散半径 颜色,
下一组;
- 两个半径都可以不写，默认都为0 - 颜色同上</p>
<p>white-space 指定如何处理空格与换行，以及自动换行
word-break  指定单词如何折行
overflow-wrap</p>
<p>direction: ltr | rtl    文字阅读方式</p>
<p>元素（即html标签）的层级关系</p>
<ul>
<li>嵌套/层叠/树形/递归/自相似/分形结构</li>
</ul>
<ul>
<li>子元素 child</li>
<li>父元素 parent</li>
<li>兄弟 siblings</li>
<li>后代 descendants</li>
<li>祖先 ancestor</li>
</ul>
<ul>
<li>替换元素与非替换元素
替换元素是没有后代元素/标签/结点的</li>
<li>替换元素是指其内容被其它不在文档里的内容替换了的元素，如：</li>
<li>img</li>
<li>radio</li>
<li>checkbox</li>
<li>input</li>
<li>iframe</li>
<li>canvas</li>
<li>object
其它大部分元素都是非替换元素</li>
</ul>
<p>元素的显示角色
块级元素:占满父元素的宽度，不会让其它元素在它的旁边.如:p，h1-6，div,
nav,header
display属性可以改变元素的显示角色
行内/内联/行间:在一行文字内产生的元素框.如a，em，strong,i,b,u,span.它们不会打断所在行的文字
html5中元素并不只区分为块级与内联，而是分为如下几个大类
+flow
+pharsing
+transparent
+meta content
+section+heading content
+embed
+intereactive</p>
<p><strong>盒模型</strong>
margin可以为负值,padding不能为负值.
background-color会充满content,padding,border.
从外到内:margin-box,border-box,padding-box,content-box
默认情况:width,height设置为content-box,可以用box-sizing可改变为border-box/content-box</p>
<p>包含块:一个元素的布局上下文.由最近的块级祖先框/表单元格/行内块元素框的内容边界构成</p>
<p>正常流:从上到下/从左到右显示.没有定位,没有浮动,不是flex元素,这个元素就在正常流里面.</p>
<p>一个盒模型的水平格式化有七个属性,其中只有三个属性可以设置为auto:左右margin和width
两个auto:
两个margin为auto:两边auto计算成一样的正值;如无法都为正,则左为0,右为负值
一个margin为auto,width为auto:相当于为auto的margin为0
三个auto:相当于左右margin为auto
零个auto:过分受限,重置右margin</p>
<p>块元素垂直格式化:(date:11-26)
如果一个块级元素的高度是百分数,这个值是包含块高度的百分数.
如果没有显式声明包含块的高度,子元素的百分比高度无效;如果用百分数表示margin或padding,值是包含块宽度的百分数.</p>
<p>边框合并:如果一个包含块高度为auto,没有border,padding,且只有块级子元素,其默认高度为最高会计子元素的外边框边界到最低块级子元素外边框,也就是说不包含子元素上下的margin,子元素margin会成为包含块margin</p>
<p>边框不合并:但是如果包含块有padding或border,则包含子元素上下的margin,是从最高子元素的上外边距边界到最低子元素下外边距边界的距离.如果子元素margin为负,包含块高度越来越小,但最低为0,不会为负值.
如果包含块有margin,产生margin合并.</p>
<p>垂直外边距合并:相邻的margin合并,保留最大的margin;如果都为负margin,保留绝对值最大者;一正一负做抵消.(兄弟元素/父子元素都有可能发生)</p>
<p><strong>行内布局</strong>
匿名文本:未包含在行内元素的字符串,在块内,不在行内.
em框:字符框,字号确定了em框高度.
内容区:在非替换元素中,就是em框串起来的框.替换元素中,是元素固有高度加上外边距,边框,内边距.
行间距:line-height - font-size,只用于非替换元素.
行内框:对于非替换元素,就是行高.替换元素,看margin-box.
行框:包裹住该行出现的行内框的最高点和最低点的最小框.
行高默认继承,行高有可能小于font-size,导致文本超出行框,两行字重叠.行高确定了行框的最小值.</p>
<p>行内格式化:</p>
<p>vertical-align:
top/bottom:元素行内框顶端对着行框顶端.
text-top/text-bottom
middle:元素行内框中点对着基线上ex的中点.
super/sub:上标/下标,不精确.
<percentage>:上移或下移line-height的百分数.</p>
<p>行内元素的边框边界由字体和字号决定,与line-height无关.
为行内元素设置外边距,在非替换元素顶端和底端没有任何效果.只应用于开始和末尾.</p>
<p>display:(改变元素显示)
inline-block:看他自身位置认为是行内元素;看里面的布局,内容认为自己在块元素里.里面有内容时,基线是内容最后一行的基线;无内容时,将margin-box底部作为基线.</p>
<p>inline-block元素触发BFC</p>
<p>BFC //Block Format Context 块级格式化上下文
不会与子元素margin重叠
自身形成一个布局单元:布局此元素内部时不用考虑其外部,可以理解为完全隔离的,可以理解为一个iframe</p>
<p><strong>定位布局</strong>
position:
static:不定位
fixed:固定定位,相对于视口定位;元素脱离常规流.(脱离常规流:他后续的元素及其包含块完全当他不存在.当不指定位置时,定位元素以原来的起点开始绘制)
relative:相对定位,相对自身原来位置,不脱离常规流,本来的位置也会保留.宽高是否生效取决于display.
absolute:绝对定位,相对于最近定了位的祖先的padding-box定位.如果找不到定位祖先,则相对于页面的首屏定位,会随着第一屏的滚动而滚动.完全脱离常规流.
sticky:粘连定位</p>
<p>非常规流块元素(定位,浮动)的宽度,首先是尽量窄到正好包裹内容,当内容足够多的时候,会把它撑大到不溢出包含块为止.但如果强行让文本不折行,则可以被撑到更宽.</p>
<p>z-index:元素上下位置设置</p>
<p>伪元素:相当于所属元素的第一个和最后一个子元素;通过xxx::before/xxx::after选中,通过content激活;为元素选择器与普通选择器不需要对比优先级,选中的一定是不同的元素;伪元素无法交互,只能在父元素发生交互时,切换对应伪元素的样式.</p>
<h3 id="浮动">浮动</h3>
<p>常规流块级元素会当浮动元素不存在,行内元素会围绕浮动元素渲染
清除浮动:
闭合浮动:某个块框通过增加自己的高度使其能够包含其浮动的后代元素(通过自己变大,包住所有后代浮动元素)
BFC(会创建一个独立的布局单元)
<strong>具体行为:</strong>
1.从高度上包裹住自己内部的浮动元素
2.margin不会与子元素重叠
3.内外布局不相关:内部元素内容改变不影响元素自己的位置,行内块元素加overflow:hidden后以margin-box底边作为其基线
4在宽度上,如果BFC元素与浮动元素有重叠,他会变窄以避开浮动元素
<strong>触发条件:</strong>
overflow不为visible
inline-block
定位
浮动
HTML元素永远BFC
display:flow/flow-root</p>
<h3 id="分列布局">分列布局</h3>
<p>column-count/column-width(同时使用可以限制min-width)
注意:margin,padding仍然会应用在内容</p>
<p>回流与重绘
relayout  repaint</p>
<hr>
<p>通过后面的元素改变前面元素的样式:</p>
<ul>
<li>input+label label会将自己的hover/active转发给input</li>
<li>focus-within伪类</li>
<li>后面的元素通过定位来模拟实现改变前面的元素的样式</li>
<li>比如微信朋元圈图片排布方式:
<ol>
<li>li:first-child:last-child{}</li>
<li>li:first-child:nth-last-child(2),li:first-child:nth-last-child(2)~li</li>
<li>li:first-child:nth-last-child(3),li:first-child:nth-last-child(3)~li</li>
<li><a href="https://jsbin.com/celaqeb/1/edit?html,css,output">https://jsbin.com/celaqeb/1/edit?html,css,output</a></li>
</ol>
</li>
</ul>
<p>pointer-events:auto/none;</p>

    </body>
    </html>